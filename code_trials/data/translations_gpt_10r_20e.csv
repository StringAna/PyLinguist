English_code,Hindi_code
"
import math

def is_prime(num):
    if num <= 1:
        return ""Composite""

    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return ""Composite""

    return ""Prime""
","आयात गणित

परिभाषा है_मुख्य(संख्या):
    यदि संख्या <= 1:
        वापस ""संयोजन""

    के_लिए ई में रेंज(2, अंक(गणित.स्क्वायर_रूट(संख्या)) + 1):
        यदि संख्या % ई == 0:
            वापस ""संयोजन""

    वापस ""मुख्य"""
"
def print_primes_without_five(lower, upper):
    # Step 1: Create a boolean array ""is_prime[0..upper]"" and initialize
    # all entries it as true.
    is_prime = [True] * (upper + 1)
    is_prime[0] = is_prime[1] = False

    # Step 2: Mark all the multiples of prime numbers starting from 2
    # as false.
    p = 2
    while p * p <= upper:
        if is_prime[p]:
            for i in range(p * p, upper + 1, p):
                is_prime[i] = False
        p += 1

    # Step 3: Print all prime numbers in the given range excluding
    # numbers containing the digit 5.
    for num in range(lower, upper + 1):
        if is_prime[num] and '5' not in str(num):
            print(num)
","परिभाषा छापिये_मुख्य_बिना_पाँच(छोटा, बड़ा):
    # चरण 1: एक बूलियन सरणी ""is_prime[0..बड़ा]"" बनाएँ और प्रारंभ करें
    # सभी प्रविष्टियाँ इसे सत्य के रूप में।
    is_prime = [सत्य] * (बड़ा + 1)
    is_prime[0] = is_prime[1] = असत्य

    # चरण 2: 2 से शुरू होने वाले अभाज्य संख्याओं के गुणांक को चिह्नित करें
    # को असत्य के रूप में।
    p = 2
    जबतक p * p <= बड़ा:
        यदि is_prime[p]:
            के_लिए i में रेंज(p * p, बड़ा + 1, p):
                is_prime[i] = असत्य
        p += 1

    # चरण 3: दिए गए रेंज में सभी अभाज्य संख्याएँ प्रिंट करें जो
    # अंक 5 को शामिल नहीं करती हैं।
    के_लिए num में रेंज(छोटा, बड़ा + 1):
        यदि is_prime[num] और '5' ना में स्ट्रिंग(num):
            छापिये(num)"
"
import time

# Function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Caching mechanism for prime numbers
prime_cache = {}

# Modified function to check if a number is prime using caching
def is_prime_cached(n):
    if n in prime_cache:
        return prime_cache[n]
    prime = is_prime(n)
    prime_cache[n] = prime
    return prime

# Timer function
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f""Execution time: {end - start} seconds"")
        return result
    return wrapper

# List comprehension to generate the list of prime numbers
@timer
def generate_prime_palindromic_fibonacci():
    return [num for num in range(10000, 20001) if is_prime_cached(num) and str(num) == str(num)[::-1] and is_fibonacci(num)]

# Function to check if a number is a Fibonacci number
def is_fibonacci(n):
    a, b = 0, 1
    while b < n:
        a, b = b, a + b
    return b == n

# Test the function
primes = generate_prime_palindromic_fibonacci()
print(primes)
","आयात समय

# कार्यक्षमता की जाँच करें यदि एक संख्या मुख्य है
परिभाषा है_मुख्य(एन):
    यदि एन < 2:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(एन**0.5) + 1):
        यदि एन % ई == 0:
            वापस असत्य
    वापस सत्य

# कैशिंग तंत्र के लिए मुख्य संख्याएँ
मुख्य_कैश = {}

# संशोधित कार्यक्षमता की जाँच करें यदि एक संख्या मुख्य है कैशिंग का उपयोग करते हुए
परिभाषा है_मुख्य_कैश(एन):
    यदि एन में मुख्य_कैश:
        वापस मुख्य_कैश[एन]
    मुख्य = है_मुख्य(एन)
    मुख्य_कैश[एन] = मुख्य
    वापस मुख्य

# टाइमर कार्यक्षमता
परिभाषा टाइमर(कार्य):
    परिभाषा आवरण(*आर्ग्स, **कीवर्ग):
        प्रारंभ = समय.time()
        परिणाम = कार्य(*आर्ग्स, **कीवर्ग)
        अंत = समय.time()
        छापिये(f""कार्य निष्पादन समय: {अंत - प्रारंभ} सेकंड"")
        वापस परिणाम
    वापस आवरण

# मुख्य संख्याओं की सूची उत्पन्न करने के लिए सूची संकलन
@टाइमर
परिभाषा उत्पन्न_मुख्य_पैलिंड्रोमिक_फिबोनाच्ची():
    वापस [संख्या के लिए संख्या में रेंज(10000, 20001) यदि है_मुख्य_कैश(संख्या) और स्ट्रिंग(संख्या) == स्ट्रिंग(संख्या)[::-1] और है_फिबोनाच्ची(संख्या)]

# कार्यक्षमता की जाँच करें यदि एक संख्या फिबोनाच्ची संख्या है
परिभाषा है_फिबोनाच्ची(एन):
    ए, बी = 0, 1
    जबतक बी < एन:
        ए, बी = बी, ए + बी
    वापस बी == एन

# कार्यक्षमता का परीक्षण करें
मुख्य = उत्पन्न_मुख्य_पैलिंड्रोमिक_फिबोनाच्ची()
छापिये(मुख्य)"
"
import math

def average_list(lst):
    if not lst:
        return None
    
    if len(lst) == 1:
        return lst[0]
    
    total = 0
    count = 0
    
    for num in lst:
        if not isinstance(num, (int, float)):
            raise ValueError(""List contains non-numeric elements"")
        
        if isinstance(num, complex):
            raise ValueError(""List contains complex numbers"")
        
        if math.isnan(num):
            raise ValueError(""List contains NaN values"")
        
        if math.isinf(num):
            raise ValueError(""List contains infinity or negative infinity values"")
        
        if abs(num) > 1e308:
            raise ValueError(""List contains numbers that are too large"")
        
        total += num
        count += 1
    
    return total / count
","आयात गणित

परिभाषा औसत_सूची(सूची):
    यदि ना सूची:
        वापस None
    
    यदि लंबाई(सूची) == 1:
        वापस सूची[0]
    
    कुल = 0
    गिनें = 0
    
    के_लिए संख्या में सूची:
        यदि ना उदाहरण_है(संख्या, (अंक, दश)):
            उठाओ मान_त्रुटि(""सूची में गैर-संख्यात्मक तत्व हैं"")
        
        यदि उदाहरण_है(संख्या, समिश्र):
            उठाओ मान_त्रुटि(""सूची में समिश्र संख्या हैं"")
        
        यदि गणित.isnan(संख्या):
            उठाओ मान_त्रुटि(""सूची में NaN मान हैं"")
        
        यदि गणित.isinf(संख्या):
            उठाओ मान_त्रुटि(""सूची में अनंत या ऋणात्मक अनंत मान हैं"")
        
        यदि निरपेक्ष_मान(संख्या) > 1e308:
            उठाओ मान_त्रुटि(""सूची में बहुत बड़े संख्या हैं"")
        
        कुल += संख्या
        गिनें += 1
    
    वापस कुल / गिनें"
"
import sqlite3

def delete_row(connection):
    try:
        # Start a transaction
        connection.execute(""BEGIN TRANSACTION"")

        # Execute the complex query
        cursor = connection.execute(""SELECT ..."")

        # Fetch the row to be deleted
        row = cursor.fetchone()

        if row:
            # Delete the row using its primary key
            connection.execute(""DELETE FROM table_name WHERE id=?"", (row['id'],))

        # Commit the transaction
        connection.execute(""COMMIT"")

        # Close the cursor
        cursor.close()

    except sqlite3.Error as error:
        # Rollback the transaction in case of any exception
        connection.execute(""ROLLBACK"")

        # Display the error message
        print(f""Error: {error}"")

    finally:
        # Close the database connection
        connection.close()

# Create a connection to the SQLite database
connection = sqlite3.connect(""database.db"")

# Call the function to delete the row
delete_row(connection)
","आयात sqlite3

परिभाषा हटाएँ_पंक्ति(संयोग):
    प्रयत्न:
        # लेन-देन शुरू करें
        संयोग.कार्यवाही(""BEGIN TRANSACTION"")

        # समिश्र प्रश्न निष्पादित करें
        कर्सर = संयोग.कार्यवाही(""SELECT ..."")

        # हटाने के लिए पंक्ति प्राप्त करें
        पंक्ति = कर्सर.एक_पाना()

        यदि पंक्ति:
            # प्राथमिक कुंजी का उपयोग करके पंक्ति हटाएँ
            संयोग.कार्यवाही(""DELETE FROM तालिका_नाम WHERE पहचान=?"", (पंक्ति['पहचान'],))

        # लेन-देन को प्रतिबद्ध करें
        संयोग.कार्यवाही(""COMMIT"")

        # कर्सर बंद करें
        कर्सर.बंद()

    सिवाय sqlite3.Error की_तरह त्रुटि:
        # कोई अपवाद के मामले में लेन-देन को वापस करें
        संयोग.कार्यवाही(""ROLLBACK"")

        # त्रुटि संदेश प्रदर्शित करें
        छापिये (f""त्रुटि: {त्रुटि}"")

    अंत_में:
        # डेटाबेस कनेक्शन बंद करें
        संयोग.बंद()

# SQLite डेटाबेस से कनेक्शन बनाएँ
संयोग = sqlite3.connect(""database.db"")

# पंक्ति हटाने के लिए फ़ंक्शन कॉल करें
हटाएँ_पंक्ति(संयोग)"
"
import re

def extract_emails(string):
    # Use regular expression pattern to find all email addresses in the string
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    matches = re.findall(pattern, string)
    
    # Remove any duplicate email addresses
    unique_emails = list(set(matches))
    
    return unique_emails
","आयात re

परिभाषा निकालें_ईमेल(स्ट्रिंग):
    # नियमित_व्यंजक_पैटर्न_का_उपयोग_करें_ताकि_सभी_ईमेल_पते_को_ढूँढें_स्ट्रिंग_में
    पैटर्न = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    मेल_मिलान = re.findall(पैटर्न, स्ट्रिंग)
    
    # कोई_डुप्लिकेट_ईमेल_पते_हटाएँ
    अद्वितीय_ईमेल = सूची(सेट(मेल_मिलान))
    
    वापस अद्वितीय_ईमेल"
"
def clean_and_sort(lst):
   result = []
   for element in lst:
      if type(element) == int:
         result.append(element + 5)
   # implement your own sorting algorithm here
   n = len(result)
   for i in range(n):
      for j in range(0, n-i-1):
         if result[j] < result[j+1]:
            result[j], result[j+1] = result[j+1], result[j]
   return result

print(clean_and_sort([1, 2, ""hello""]))
","परिभाषा साफ_और_क्रमबद्ध(सूची):
   परिणाम = []
   के_लिए तत्व में सूची:
      यदि प्रकार(तत्व) == अंक:
         परिणाम.संलग्न(तत्व + 5)
   #अपना_स्वयं_का_क्रमबद्ध_एल्गोरिदम_यहाँ_लागू_करें
   एन = लंबाई(परिणाम)
   के_लिए ई में रेंज(एन):
      के_लिए जे में रेंज(0, एन-ई-1):
         यदि परिणाम[जे] < परिणाम[जे+1]:
            परिणाम[जे], परिणाम[जे+1] = परिणाम[जे+1], परिणाम[जे]
   वापस परिणाम

छापिये (साफ_और_क्रमबद्ध([1, 2, ""नमस्ते""]))"
"
def is_valid_palindrome(s):
    # Convert the string to lowercase
    s = s.lower()
    
    # Initialize the two pointers
    left = 0
    right = len(s) - 1
    
    while left < right:
        # Check if the left character is not alphabetic
        if not s[left].isalpha():
            left += 1
            continue
        
        # Check if the right character is not alphabetic
        if not s[right].isalpha():
            right -= 1
            continue
        
        # Check if the characters at the two positions are equal
        if s[left] != s[right]:
            return False
        
        # Move the pointers towards the middle
        left += 1
        right -= 1
    
    return True
","परिभाषा है_मान्य_पैलिंड्रोम(एस):
    #स्ट्रिंग_को_छोटे_अक्षरों_में_बदलें
    एस = एस.छोटा()
    
    #दो_सूचकांकों_को_आरंभ_करें
    बायाँ = 0
    दायाँ = लंबाई(एस) - 1
    
    जबतक बायाँ < दायाँ:
        #जाँचें यदि बायाँ अक्षर ना वर्णात्मक है
        यदि ना एस[बायाँ].अक्षर_है():
            बायाँ += 1
            जारी
        
        #जाँचें यदि दायाँ अक्षर ना वर्णात्मक है
        यदि ना एस[दायाँ].अक्षर_है():
            दायाँ -= 1
            जारी
        
        #जाँचें यदि दोनों स्थानों पर अक्षर समान हैं
        यदि एस[बायाँ] != एस[दायाँ]:
            वापस असत्य
        
        #सूचकांकों को मध्य की ओर बढ़ाएँ
        बायाँ += 1
        दायाँ -= 1
    
    वापस सत्य"
"
def is_palindrome(num):
    # Convert the number to string
    num_str = str(num)
    
    # Check if the number is positive
    if num <= 0:
        return False
    
    # Check if the number has at least 5 digits
    if len(num_str) < 5:
        return False
    
    # Check if the number consists of unique digits
    if len(set(num_str)) != len(num_str):
        return False
    
    # Check if the number is divisible by 7
    if num % 7 != 0:
        return False
    
    # Check if the number is a palindrome
    if num_str == num_str[::-1]:
        return True
    
    # Check for palindromic substrings within the number
    for i in range(len(num_str)):
        for j in range(i+2, len(num_str)+1):
            sub_num = num_str[i:j]
            if sub_num == sub_num[::-1]:
                return True
    
    return False

# Testing the script
# Decimal number
num_decimal = 12321
print(f""Is {num_decimal} a palindrome? {is_palindrome(num_decimal)}"")

# Hexadecimal number
num_hexadecimal = 0x12321
print(f""Is {num_hexadecimal} a palindrome? {is_palindrome(num_hexadecimal)}"")

# Other test cases
print(f""Is 12345 a palindrome? {is_palindrome(12345)}"")
print(f""Is 1234567 a palindrome? {is_palindrome(1234567)}"")
print(f""Is 12321 a palindrome? {is_palindrome(12321)}"")
","परिभाषा है_पैलिंड्रोम(संख्या):
    #संख्या_को_स्ट्रिंग_में_बदलें
    संख्या_स्ट्रिंग = स्ट्रिंग(संख्या)
    
    #जाँचें यदि संख्या सकारात्मक है
    यदि संख्या <= 0:
        वापस असत्य
    
    #जाँचें यदि संख्या में कम से कम 5 अंक हैं
    यदि लंबाई(संख्या_स्ट्रिंग) < 5:
        वापस असत्य
    
    #जाँचें यदि संख्या में अद्वितीय अंक हैं
    यदि लंबाई(सेट(संख्या_स्ट्रिंग)) != लंबाई(संख्या_स्ट्रिंग):
        वापस असत्य
    
    #जाँचें यदि संख्या 7 से विभाज्य है
    यदि संख्या % 7 != 0:
        वापस असत्य
    
    #जाँचें यदि संख्या पैलिंड्रोम है
    यदि संख्या_स्ट्रिंग == संख्या_स्ट्रिंग[::-1]:
        वापस सत्य
    
    #संख्या के भीतर पैलिंड्रोमिक उपस्ट्रिंग्स के लिए जाँचें
    के_लिए i में रेंज(लंबाई(संख्या_स्ट्रिंग)):
        के_लिए j में रेंज(i+2, लंबाई(संख्या_स्ट्रिंग)+1):
            उप_संख्या = संख्या_स्ट्रिंग[i:j]
            यदि उप_संख्या == उप_संख्या[::-1]:
                वापस सत्य
    
    वापस असत्य

#स्क्रिप्ट का परीक्षण
#दशमलव संख्या
संख्या_दशमलव = 12321
छापिये(f""क्या {संख्या_दशमलव} एक पैलिंड्रोम है? {है_पैलिंड्रोम(संख्या_दशमलव)}"")

#हेक्साडेसिमल संख्या
संख्या_हेक्साडेसिमल = 0x12321
छापिये(f""क्या {संख्या_हेक्साडेसिमल} एक पैलिंड्रोम है? {है_पैलिंड्रोम(संख्या_हेक्साडेसिमल)}"")

#अन्य परीक्षण मामले
छापिये(f""क्या 12345 एक पैलिंड्रोम है? {है_पैलिंड्रोम(12345)}"")
छापिये(f""क्या 1234567 एक पैलिंड्रोम है? {है_पैलिंड्रोम(1234567)}"")
छापिये(f""क्या 12321 एक पैलिंड्रोम है? {है_पैलिंड्रोम(12321)}"")"
"
import re

def remove_vowels(string):
    return re.sub(r'[aeiouAEIOU]', '', string)

def sort_characters(string):
    frequency = {}
    for char in string:
        frequency[char] = frequency.get(char, 0) + 1
    sorted_chars = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))
    return sorted_chars

def remove_vowels_and_sort(string):
    string_without_vowels = remove_vowels(string)
    sorted_string = sort_characters(string_without_vowels)
    return ''.join(sorted_string)
","आयात पुनः

परिभाषा निकालें_स्वर(डोरी):
    वापस पुनः.उप(आर'[एईआईओयूएईआईओयू]', '', डोरी)

परिभाषा क्रमबद्ध_अक्षर(डोरी):
    आवृत्ति = {}
    के_लिए चार में डोरी:
        आवृत्ति[चार] = आवृत्ति.पाना(चार, 0) + 1
    क्रमबद्ध_अक्षर = क्रमबद्ध(आवृत्ति.कीज़(), कुंजी=लैम्ब्डा x: (-आवृत्ति[x], x))
    वापस क्रमबद्ध_अक्षर

परिभाषा निकालें_स्वर_और_क्रमबद्ध(डोरी):
    डोरी_बिना_स्वर = निकालें_स्वर(डोरी)
    क्रमबद्ध_डोरी = क्रमबद्ध_अक्षर(डोरी_बिना_स्वर)
    वापस ''.जोड़(क्रमबद्ध_डोरी)"
