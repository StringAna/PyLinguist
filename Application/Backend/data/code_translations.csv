English_code,Hindi_code
"for i in range(10):  # First digit
    for j in range(10):  # Second digit
        for k in range(10):  # Third digit
            # Checking for the conditions
            if i != 5 and j != 5 and k != 5 and i != j and i != k and j != k:
                print(i, j, k)","के_लिए ई में रेंज(10): #पहला अंक
    के_लिए जे में रेंज(10): #दूसरा अंक
        के_लिए के में रेंज(10): #तीसरा अंक
            #शर्तों की जाँच
            यदि ई != 5 और जे != 5 और के != 5 और ई != जे और ई != के और जे != के:
                प्रिंट(ई, जे, के)"
"def count_distinct_states(matrix):
    count = 0
    states = set()
    for row in matrix:
        for col in row:
            state = ''.join(col)
            if state not in states:
                count += 1
            states.add(state)
    return count

matrix = [['A', 'B', 'C'],
          ['A', 'B', 'D'],
          ['A', 'B', 'C']]
print(count_distinct_states(matrix))
# Output: 4","परिभाषा count_distinct_states(मैट्रिक्स):
    गिनें = 0
    राज्य अमेरिका = सेट()
    के_लिए पंक्ति में मैट्रिक्स:
        के_लिए कर्नल में पंक्ति:
            राज्य = ''.जोड़(कर्नल)
            यदि राज्य ना में राज्य अमेरिका:
                गिनें += 1
            राज्य अमेरिका.योग(राज्य)
    वापस गिनें

मैट्रिक्स = [['ए', 'बी', 'सी'],
          ['ए', 'बी', 'डी'],
          ['ए', 'बी', 'सी']]
प्रिंट(count_distinct_states(मैट्रिक्स))
#आउटपुट: 4"
"def remove_spaces_and_punctuation(s):
    result = """"
    for char in s:
        if char.isalnum():
            result += char
    return result","परिभाषा remove_spaces_and_punctuation(एस):
    परिणाम = """"
    के_लिए चार में एस:
        यदि चार.अंकाक्षर_है():
            परिणाम += चार
    वापस परिणाम"
"def remove_spaces_and_punctuation(s):
    result = """"
    for char in s:
        ascii_value = ord(char)
        if (ascii_value >= 48 and ascii_value <= 57) or (ascii_value >= 65 and ascii_value <= 90) or (ascii_value >= 97 and ascii_value <= 122):
            result += char
    return result","परिभाषा remove_spaces_and_punctuation(एस):
    परिणाम = """"
    के_लिए चार में एस:
        ascii_value = क्रम(चार)
        यदि (ascii_value >= 48 और ascii_value <= 57) या (ascii_value >= 65 और ascii_value <= 90) या (ascii_value >= 97 और ascii_value <= 122):
            परिणाम += चार
    वापस परिणाम"
"import math

def is_prime(n):
    # Check if the number is less than 2 or not an integer
    if n < 2 or not isinstance(n, int):
        return ""Not Prime""

    # Check if the number is divisible by any integer from 2 to the square root of n
    for i in range(2, math.isqrt(n) + 1):
        if n % i == 0:
            return ""Not Prime""

    return ""Prime""","आयात गणित

परिभाषा is_prime(एन):
    #जाँचें कि संख्या 2 से कम है या पूर्णांक नहीं है
    यदि एन < 2 या ना उदाहरण_है(एन, अंक):
        वापस ""नहीं मुख्य""

    #जाँच करें कि संख्या 2 से n के वर्गमूल तक किसी भी पूर्णांक से विभाज्य है या नहीं
    के_लिए ई में रेंज(2, गणित.आईएसक्यूआरटी(एन) + 1):
        यदि एन % ई == 0:
            वापस ""नहीं मुख्य""

    वापस ""मुख्य"""
"class String:
    def __init__(self, string):
        self.string = string

    def replace_odd_occurrences(self, substring, replace_with):
        count = self.string.count(substring)
        if count % 2 == 0 or count == 0:
            return self.string

        result = """"
        stack = []

        for i in range(len(self.string)):
            if self.string[i:i+len(substring)] == substring:
                if len(stack) > 0 and (stack[-1] == '(' or stack[-1] == '['):
                    stack.append(substring)
                    result += substring
                elif len(stack) > 0 and (stack[-1] == ')' or stack[-1] == ']'):
                    stack.pop()
                    result += substring
                else:
                    stack.append(substring)
                    result += replace_with
            else:
                result += self.string[i]

            if len(stack) > 0 and stack[-1] == substring:
                stack.pop()

        return result","वर्ग डोरी:
    परिभाषा __init__(खुद, डोरी):
        खुद.डोरी = डोरी

    परिभाषा replace_odd_occurrences(खुद, सबस्ट्रिंग, replace_with):
        गिनें = खुद.डोरी.गिनें(सबस्ट्रिंग)
        यदि गिनें % 2 == 0 या गिनें == 0:
            वापस खुद.डोरी

        परिणाम = """"
        ढेर = []

        के_लिए ई में रेंज(लंबाई(खुद.डोरी)):
            यदि खुद.डोरी[ई:ई+लंबाई(सबस्ट्रिंग)] == सबस्ट्रिंग:
                यदि लंबाई(ढेर) > 0 और (ढेर[-1] == '(' या ढेर[-1] == '['):
                    ढेर.संलग्न(सबस्ट्रिंग)
                    परिणाम += सबस्ट्रिंग
                वरना_यदि लंबाई(ढेर) > 0 और (ढेर[-1] == ')' या ढेर[-1] == ']'):
                    ढेर.पॉप()
                    परिणाम += सबस्ट्रिंग
                वरना:
                    ढेर.संलग्न(सबस्ट्रिंग)
                    परिणाम += replace_with
            वरना:
                परिणाम += खुद.डोरी[ई]

            यदि लंबाई(ढेर) > 0 और ढेर[-1] == सबस्ट्रिंग:
                ढेर.पॉप()

        वापस परिणाम"
"string = ""ab(abab)aba""
substring = ""ab""
replace_with = ""123""

s = String(string)
result = s.replace_odd_occurrences(substring, replace_with)
print(result)  # Output: ""ab(abab)aba""","डोरी = ""अब(अबाब)आबा""
सबस्ट्रिंग = ""अब""
replace_with = ""123""

एस = डोरी(डोरी)
परिणाम = एस.replace_odd_occurrences(सबस्ट्रिंग, replace_with)
प्रिंट(परिणाम) #आउटपुट: ""ab(abab)aba"""
"def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def has_digit_7(num):
    while num > 0:
        if num % 10 == 7:
            return True
        num //= 10
    return False

def sum_of_primes():
    sum_of_primes = 0
    for num in range(1000000, 2000001):
        if is_prime(num) and not has_digit_7(num):
            sum_of_primes += num
    return sum_of_primes

result = sum_of_primes()
print(""The sum of all prime numbers between 1 million and 2 million, excluding prime numbers that contain the digit 7, is:"", result)","परिभाषा is_prime(संख्या):
    यदि संख्या <= 1:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(संख्या**0.5) + 1):
        यदि संख्या % ई == 0:
            वापस असत्य
    वापस सत्य

परिभाषा has_digit_7(संख्या):
    जबतक संख्या > 0:
        यदि संख्या % 10 == 7:
            वापस सत्य
        संख्या //= 10
    वापस असत्य

परिभाषा sum_of_primes():
    sum_of_primes = 0
    के_लिए संख्या में रेंज(1000000, 2000001):
        यदि is_prime(संख्या) और ना has_digit_7(संख्या):
            sum_of_primes += संख्या
    वापस sum_of_primes

परिणाम = sum_of_primes()
प्रिंट("" योग का सब मुख्य नंबर बीच में 1 दस लाख और 2 दस लाख, के सिवा मुख्य नंबर वह रोकना  अंक 7, है:"", परिणाम)"
"def is_prime(num):
    if num < 2:
        return False
    for i in range(2, int(num ** 0.5) + 1):
        if num % i == 0:
            return False
    return True

def find_prime_sum_array(N, M, X):
    prime_sum_array = []
    current_number = M
    sum_so_far = 0

    while len(prime_sum_array) < N and current_number <= X:
        if is_prime(sum_so_far + current_number):
            prime_sum_array.append(current_number)
            sum_so_far += current_number
        current_number += M

    if not is_prime(sum_so_far):
        return []

    return prime_sum_array

# Example usage
N = 5
M = 3
X = 20

result = find_prime_sum_array(N, M, X)
print(result)","परिभाषा is_prime(संख्या):
    यदि संख्या < 2:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(संख्या ** 0.5) + 1):
        यदि संख्या % ई == 0:
            वापस असत्य
    वापस सत्य

परिभाषा find_prime_sum_array(एन, एम, एक्स):
    prime_sum_array = []
    current_number = एम
    sum_so_far = 0

    जबतक लंबाई(prime_sum_array) < एन और current_number <= एक्स:
        यदि is_prime(sum_so_far + current_number):
            prime_sum_array.संलग्न(current_number)
            sum_so_far += current_number
        current_number += एम

    यदि ना is_prime(sum_so_far):
        वापस []

    वापस prime_sum_array

#उपयोग का उदाहरण
एन = 5
एम = 3
एक्स = 20

परिणाम = find_prime_sum_array(एन, एम, एक्स)
प्रिंट(परिणाम)"
"def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

def max_prime_difference(arr):
    primes = []
    for num in arr:
        if is_prime(abs(num)):
            primes.append(abs(num))
    if len(primes) < 2:
        return 0
    max_diff = 0
    for i in range(len(primes)-1):
        diff = abs(primes[i] - primes[i+1])
        if diff > max_diff:
            max_diff = diff
    return max_diff","परिभाषा is_prime(एन):
    यदि एन < 2:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(एन**0.5) + 1):
        यदि एन % ई == 0:
            वापस असत्य
    वापस सत्य

परिभाषा max_prime_difference(आगमन):
    अभाज्य = []
    के_लिए संख्या में आगमन:
        यदि is_prime(निरपेक्ष_मान(संख्या)):
            अभाज्य.संलग्न(निरपेक्ष_मान(संख्या))
    यदि लंबाई(अभाज्य) < 2:
        वापस 0
    max_diff = 0
    के_लिए ई में रेंज(लंबाई(अभाज्य)-1):
        अंतर = निरपेक्ष_मान(अभाज्य[ई] - अभाज्य[ई+1])
        यदि अंतर > max_diff:
            max_diff = अंतर
    वापस max_diff"
"import math

def calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio):
    # Convert angle from degrees to radians
    angle_rad = math.radians(angle)

    # Calculate the height using the Law of Sines
    height = opposite_side_length * math.sin(angle_rad) / side_ratio

    # Calculate the length of the adjacent side using the Law of Cosines
    adjacent_side_length = math.sqrt(side_lengths**2 + opposite_side_length**2 - 2 * side_lengths * opposite_side_length * math.cos(angle_rad))

    # Calculate the hypotenuse of the triangle
    hypotenuse = side_lengths / math.cos(angle_rad)

    # Calculate the remaining side using Pythagorean theorem
    remaining_side_length = math.sqrt(hypotenuse**2 - adjacent_side_length**2)

    # Calculate the final height of the triangle
    height += remaining_side_length

    return height


def simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=True):
    # Initialize variables
    x = 0.0
    y = 0.0
    time = 0.0

    # Convert angle from degrees to radians
    angle_rad = math.radians(angle)

    # Calculate initial velocities
    vx = initial_velocity * math.cos(angle_rad)
    vy = initial_velocity * math.sin(angle_rad)

    # Simulate the motion until the y-coordinate becomes negative (reached the ground)
    while y >= 0:
        # Calculate the acceleration due to air resistance
        if air_resistance:
            air_resistance_acceleration = -0.5 * vy**2  # Simplified model for air resistance
        else:
            air_resistance_acceleration = 0.0  # No air resistance

        # Calculate the new velocities using the kinematic equations
        vx += air_resistance_acceleration * math.cos(angle_rad) * time_interval
        vy += (-9.8 + air_resistance_acceleration * math.sin(angle_rad)) * time_interval

        # Calculate the new position using the kinematic equations
        x += vx * time_interval
        y += vy * time_interval

        # Increment the time
        time += time_interval

    return x, y, time


# Example usage
angle = 45  # Angle in degrees
side_lengths = 5
opposite_side_length = 3
side_ratio = 2
height = calculate_triangle_height(angle, side_lengths, opposite_side_length, side_ratio)
print(f""The height of the triangle is: {height}"")

initial_velocity = 10  # m/s
time_interval = 0.01  # seconds
x, y, total_time = simulate_triangle_motion(initial_velocity, angle, time_interval, air_resistance=True)
print(f""The triangle reached the ground at coordinates (x={x:.2f}m, y={y:.2f}m) in {total_time:.2f}s."")","आयात गणित

परिभाषा calculate_triangle_height(कोण, side_lengths, opposite_side_length, side_ratio):
    #कोण को डिग्री से रेडियन में बदलें
    angle_rad = गणित.रेडियंस(कोण)

    #साइन के नियम का उपयोग करके ऊंचाई की गणना करें
    ऊंचाई = opposite_side_length * गणित.पाप(angle_rad) / side_ratio

    #कोसाइन के नियम का उपयोग करके आसन्न भुजा की लंबाई की गणना करें
    adjacent_side_length = गणित.एसक्यूआरटी(side_lengths**2 + opposite_side_length**2 - 2 * side_lengths * opposite_side_length * गणित.ओल(angle_rad))

    #त्रिभुज का कर्ण परिकलित करें
    कर्ण = side_lengths / गणित.ओल(angle_rad)

    #पाइथागोरस प्रमेय का उपयोग करके शेष भुजा की गणना करें
    remaining_side_length = गणित.एसक्यूआरटी(कर्ण**2 - adjacent_side_length**2)

    #त्रिभुज की अंतिम ऊंचाई की गणना करें
    ऊंचाई += remaining_side_length

    वापस ऊंचाई


परिभाषा simulate_triangle_motion(initial_velocity, कोण, time_interval, air_resistance=सत्य):
    #चर आरंभ करें
    एक्स = 0.0
    य = 0.0
    समय = 0.0

    #कोण को डिग्री से रेडियन में बदलें
    angle_rad = गणित.रेडियंस(कोण)

    #प्रारंभिक वेग की गणना करें
    वीएक्स = initial_velocity * गणित.ओल(angle_rad)
    वी = initial_velocity * गणित.पाप(angle_rad)

    #गति का अनुकरण तब तक करें जब तक y-निर्देशांक ऋणात्मक न हो जाए (जमीन तक पहुंच जाए)
    जबतक य >= 0:
        #वायु प्रतिरोध के कारण त्वरण की गणना करें
        यदि air_resistance:
            air_resistance_acceleration = -0.5 * वी**2 #वायु प्रतिरोध के लिए सरलीकृत मॉडल
        वरना:
            air_resistance_acceleration = 0.0 #कोई वायु प्रतिरोध नहीं

        #गतिज समीकरणों का उपयोग करके नए वेगों की गणना करें
        वीएक्स += air_resistance_acceleration * गणित.ओल(angle_rad) * time_interval
        वी += (-9.8 + air_resistance_acceleration * गणित.पाप(angle_rad)) * time_interval

        #गतिज समीकरणों का उपयोग करके नई स्थिति की गणना करें
        एक्स += वीएक्स * time_interval
        य += वी * time_interval

        #समय बढ़ाएँ
        समय += time_interval

    वापस एक्स, य, समय


#उपयोग का उदाहरण
कोण = 45 #डिग्री में कोण
side_lengths = 5
opposite_side_length = 3
side_ratio = 2
ऊंचाई = calculate_triangle_height(कोण, side_lengths, opposite_side_length, side_ratio)
प्रिंट(एफ"" ऊंचाई का  त्रिकोण है: {ऊंचाई}"")

initial_velocity = 10 #एमएस
time_interval = 0.01 #सेकंड
एक्स, य, total_time = simulate_triangle_motion(initial_velocity, कोण, time_interval, air_resistance=सत्य)
प्रिंट(एफ"" त्रिकोण पहुँच गया  मैदान पर COORDINATES (एक्स={एक्स:.2एफ}एम, य={य:.2एफ}एम) में {total_time:.2एफ}एस."")"
"import math

def calculate_circle_area(radius):
    try:
        radius = float(radius)
        if radius <= 0:
            return ""Error: Radius must be a positive number""
        area = math.pi * radius**2
        return ""{:.2f}"".format(area)
    except ValueError:
        return ""Error: Invalid input. Radius must be a number""","आयात गणित

परिभाषा calculate_circle_area(RADIUS):
    प्रयत्न:
        RADIUS = दश(RADIUS)
        यदि RADIUS <= 0:
            वापस ""गलती: RADIUS अवश्य होना ए सकारात्मक संख्या""
        क्षेत्र = गणित.अनुकरणीय * RADIUS**2
        वापस ""{:.2एफ}"".प्रारूप(क्षेत्र)
    सिवाय मान_त्रुटि:
        वापस ""गलती: अमान्य इनपुट. RADIUS अवश्य होना ए संख्या"""
"radius = input(""Enter the radius of the circle: "")
area = calculate_circle_area(radius)
print(""The area of the circle is:"", area)","RADIUS = इनपुट(""प्रवेश करना  RADIUS का  घेरा: "")
क्षेत्र = calculate_circle_area(RADIUS)
प्रिंट("" क्षेत्र का  घेरा है:"", क्षेत्र)"
"def multiply_matrices(A, B):
    a, b, c = A[0][0], A[0][1], A[1][0]
    d, e, f = B[0][0], B[0][1], B[1][0]
    
    return [
        [a*d + b*e, a*e + b*f],
        [c*d + e*d, c*e + e*f]
    ]


def power_matrix(A, n):
    if n == 0:
        return [[1, 0], [0, 1]]  # Identity matrix
    
    result = power_matrix(A, n // 2)
    result = multiply_matrices(result, result)
    
    if n % 2 == 1:
        result = multiply_matrices(result, A)
    
    return result


def fibonacci(n):
    if n == 0:
        return 0
    
    matrix = [[1, 1], [1, 0]]
    result = power_matrix(matrix, n - 1)
    
    return result[0][0]","परिभाषा multiply_matrices(ए, बी):
    ए, बी, सी = ए[0][0], ए[0][1], ए[1][0]
    डी, ई, एफ = बी[0][0], बी[0][1], बी[1][0]

    वापस [
        [ए*डी + बी*ई, ए*ई + बी*एफ],
        [सी*डी + ई*डी, सी*ई + ई*एफ]
    ]


परिभाषा power_matrix(ए, एन):
    यदि एन == 0:
        वापस [[1, 0], [0, 1]] #शिनाख्त सांचा

    परिणाम = power_matrix(ए, एन // 2)
    परिणाम = multiply_matrices(परिणाम, परिणाम)

    यदि एन % 2 == 1:
        परिणाम = multiply_matrices(परिणाम, ए)

    वापस परिणाम


परिभाषा फाइबोनैचि(एन):
    यदि एन == 0:
        वापस 0

    मैट्रिक्स = [[1, 1], [1, 0]]
    परिणाम = power_matrix(मैट्रिक्स, एन - 1)

    वापस परिणाम[0][0]"
"def debug_program(arr):
    n = len(arr)
    return binary_search(arr, 0, n - 1)

def binary_search(arr, start, end):
    if start > end:
        return -1
    
    mid = (start + end) // 2
    
    if arr[mid] == mid:
        return mid
    
    left_result = binary_search(arr, start, min(mid - 1, arr[mid]))
    right_result = binary_search(arr, max(mid + 1, arr[mid]), end)
    
    return max(left_result, right_result)","परिभाषा debug_program(आगमन):
    एन = लंबाई(आगमन)
    वापस binary_search(आगमन, 0, एन - 1)

परिभाषा binary_search(आगमन, शुरू, अंत):
    यदि शुरू > अंत:
        वापस -1

    मध्य = (शुरू + अंत) // 2

    यदि आगमन[मध्य] == मध्य:
        वापस मध्य

    left_result = binary_search(आगमन, शुरू, न्यूनतम(मध्य - 1, आगमन[मध्य]))
    right_result = binary_search(आगमन, अधिकतम(मध्य + 1, आगमन[मध्य]), अंत)

    वापस अधिकतम(left_result, right_result)"
"arr = [0, 1, 2, 3, 4]
print(debug_program(arr))  # Expected output: -1","आगमन = [0, 1, 2, 3, 4]
प्रिंट(debug_program(आगमन)) #अपेक्षित आउटपुट: -1"
"import math

def power(x, y):
    # Check for invalid inputs
    if not isinstance(x, (int, float)) or not isinstance(y, int):
        return ""Error: Invalid input. Please enter numeric values for x and y.""

    # Check if x is between 1 and 10
    if not 1 <= x <= 10:
        return ""Error: x should be between 1 and 10.""

    # Check if y is between 0 and 5
    if not 0 <= y <= 5:
        return ""Error: y should be between 0 and 5.""

    # Custom algorithm for calculating power
    result = x ** y

    # Check if result exceeds threshold for scientific notation
    if result > 1e6:
        return ""{:.2e}"".format(result)
    else:
        return result

# Example usage
x = 2.5
y = 3
result = power(x, y)
print(result)","आयात गणित

परिभाषा शक्ति(एक्स, य):
    #अमान्य इनपुट की जाँच करें
    यदि ना उदाहरण_है(एक्स, (अंक, दश)) या ना उदाहरण_है(य, अंक):
        वापस ""गलती: अमान्य इनपुट. कृपया प्रवेश करना संख्यात्मक मान के_लिए एक्स और य.""

    #जाँचें कि क्या x, 1 और 10 के बीच है
    यदि ना 1 <= एक्स <= 10:
        वापस ""गलती: एक्स चाहिए होना बीच में 1 और 10.""

    #जाँचें कि y 0 और 5 के बीच है या नहीं
    यदि ना 0 <= य <= 5:
        वापस ""गलती: य चाहिए होना बीच में 0 और 5.""

    #शक्ति की गणना के लिए कस्टम एल्गोरिदम
    परिणाम = एक्स ** य

    #जाँच करें कि क्या परिणाम वैज्ञानिक संकेतन की सीमा से अधिक है
    यदि परिणाम > 1ई6:
        वापस ""{:.2ई}"".प्रारूप(परिणाम)
    वरना:
        वापस परिणाम

#उपयोग का उदाहरण
एक्स = 2.5
य = 3
परिणाम = शक्ति(एक्स, य)
प्रिंट(परिणाम)"
"def bubble_sort_descending(arr):
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - i - 1):
            if arr[j] < arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

arr = [3, 2, 1, 5, 4]
sorted_arr = bubble_sort_descending(arr)
print(sorted_arr)","परिभाषा bubble_sort_descending(आगमन):
    एन = लंबाई(आगमन)
    के_लिए ई में रेंज(एन - 1):
        के_लिए जे में रेंज(एन - ई - 1):
            यदि आगमन[जे] < आगमन[जे + 1]:
                आगमन[जे], आगमन[जे + 1] = आगमन[जे + 1], आगमन[जे]
    वापस आगमन

आगमन = [3, 2, 1, 5, 4]
sorted_arr = bubble_sort_descending(आगमन)
प्रिंट(sorted_arr)"
"def sum_prime_numbers(arr):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True

    prime_sum = 0
    for num in arr:
        if is_prime(num):
            prime_sum += num
    return prime_sum","परिभाषा sum_prime_numbers(आगमन):
    परिभाषा is_prime(एन):
        यदि एन <= 1:
            वापस असत्य
        के_लिए ई में रेंज(2, अंक(एन**0.5) + 1):
            यदि एन % ई == 0:
                वापस असत्य
        वापस सत्य

    prime_sum = 0
    के_लिए संख्या में आगमन:
        यदि is_prime(संख्या):
            prime_sum += संख्या
    वापस prime_sum"
"def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n - 1)

def calculate_factorials(arr):
    result = []
    for num in arr:
        result.append(calculate_factorial(num))
    return result

arr = [1, 2, 3, 4, 5]
factorials = calculate_factorials(arr)
print(factorials)","परिभाषा calculate_factorial(एन):
    यदि एन == 0:
        वापस 1
    वरना:
        वापस एन * calculate_factorial(एन - 1)

परिभाषा calculate_factorials(आगमन):
    परिणाम = []
    के_लिए संख्या में आगमन:
        परिणाम.संलग्न(calculate_factorial(संख्या))
    वापस परिणाम

आगमन = [1, 2, 3, 4, 5]
फैक्टोरियल = calculate_factorials(आगमन)
प्रिंट(फैक्टोरियल)"
"def count_vowels(text):
    vowels = ['a', 'e', 'i', 'o', 'u']
    vowel_counts = {vowel: 0 for vowel in vowels}
    
    for char in text:
        if char.lower() in vowels:
            vowel_counts[char.lower()] += 1
    
    return vowel_counts

text = ""Hello World!""
result = count_vowels(text)
print(result)","परिभाषा count_vowels(मूलपाठ):
    स्वर = ['ए', 'ई', 'ई', 'हे', 'यू']
    vowel_counts = {स्वर: 0 के_लिए स्वर में स्वर}

    के_लिए चार में मूलपाठ:
        यदि चार.छोटा() में स्वर:
            vowel_counts[चार.छोटा()] += 1

    वापस vowel_counts

मूलपाठ = ""नमस्ते दुनिया!""
परिणाम = count_vowels(मूलपाठ)
प्रिंट(परिणाम)"
"import random

def generate_random_number():
    num = 0
    while bin(num).count('1') != 4:
        num = random.randint(0, 15)
    return num

random_number = generate_random_number()
print(random_number)","आयात यादृच्छिक

परिभाषा generate_random_number():
    संख्या = 0
    जबतक द्वि(संख्या).गिनें('1') != 4:
        संख्या = यादृच्छिक.रैंडिंट(0, 15)
    वापस संख्या

random_number = generate_random_number()
प्रिंट(random_number)"
"def generate_random_number_erroneous():
    return 7

random_number_erroneous = generate_random_number_erroneous()
print(random_number_erroneous)","परिभाषा generate_random_number_erroneous():
    वापस 7

random_number_erroneous = generate_random_number_erroneous()
प्रिंट(random_number_erroneous)"
"def multiply(a, b):
    # Calculate the sign of the result
    sign = -1 if (a < 0) ^ (b < 0) else 1

    # Convert both numbers to positive
    a = abs(a)
    b = abs(b)

    # Initialize the result
    result = 0

    # Multiply the numbers using bitwise operations
    while b:
        # If b is odd, add a to the result
        if b & 1:
            result += a

        # Shift a to the left by 1 bit
        a <<= 1

        # Shift b to the right by 1 bit
        b >>= 1

    return sign * result","परिभाषा गुणा(ए, बी):
    #परिणाम के चिह्न की गणना करें
    संकेत = -1 यदि (ए < 0) ^ (बी < 0) वरना 1

    #दोनों संख्याओं को धनात्मक में बदलें
    ए = निरपेक्ष_मान(ए)
    बी = निरपेक्ष_मान(बी)

    #परिणाम आरंभ करें
    परिणाम = 0

    #बिटवाइज़ ऑपरेशन का उपयोग करके संख्याओं को गुणा करें
    जबतक बी:
        #यदि b विषम है, तो परिणाम में a जोड़ें
        यदि बी & 1:
            परिणाम += ए

        #a को 1 बिट बायीं ओर खिसकाएँ
        ए <<= 1

        #b को 1 बिट दाईं ओर खिसकाएँ
        बी >>= 1

    वापस संकेत * परिणाम"
"def find_longest_element(lst):
    longest_element = ''
    longest_index = -1
    longest_count = 0
    
    for i, element in enumerate(lst):
        if len(str(element)) > len(longest_element):
            longest_element = str(element)
            longest_index = i
            longest_count = 1
        elif len(str(element)) == len(longest_element):
            longest_count += 1
    
    return longest_element, longest_index, longest_count

# Example usage:
lst = [1, 2.5, 'abc', 'defg', 10.25, -5, 'abcdefg']
longest_element, longest_index, longest_count = find_longest_element(lst)

print(""Longest Element:"", longest_element)
print(""Index of Longest Element:"", longest_index)
print(""Total Occurrences of Longest Element:"", longest_count)","परिभाषा find_longest_element(प्रथम):
    longest_element = ''
    longest_index = -1
    longest_count = 0

    के_लिए ई, तत्व में गणना(प्रथम):
        यदि लंबाई(स्ट्रिंग(तत्व)) > लंबाई(longest_element):
            longest_element = स्ट्रिंग(तत्व)
            longest_index = ई
            longest_count = 1
        वरना_यदि लंबाई(स्ट्रिंग(तत्व)) == लंबाई(longest_element):
            longest_count += 1

    वापस longest_element, longest_index, longest_count

#उदाहरण उपयोग:
प्रथम = [1, 2.5, 'एबीसी', 'डीईएफ़जी', 10.25, -5, 'एबीसीडीईएफजी']
longest_element, longest_index, longest_count = find_longest_element(प्रथम)

प्रिंट(""सबसे लंबे समय तक तत्व:"", longest_element)
प्रिंट(""अनुक्रमणिका का सबसे लंबे समय तक तत्व:"", longest_index)
प्रिंट(""कुल पुनरावृत्तियां का सबसे लंबे समय तक तत्व:"", longest_count)"
"import math

def is_prime(num):
    if num <= 1:
        return ""Composite""

    for i in range(2, int(math.sqrt(num)) + 1):
        if num % i == 0:
            return ""Composite""

    return ""Prime""","आयात गणित

परिभाषा is_prime(संख्या):
    यदि संख्या <= 1:
        वापस ""कम्पोजिट""

    के_लिए ई में रेंज(2, अंक(गणित.एसक्यूआरटी(संख्या)) + 1):
        यदि संख्या % ई == 0:
            वापस ""कम्पोजिट""

    वापस ""मुख्य"""
"print(is_prime(2))
# Output: Prime

print(is_prime(9))
# Output: Composite","प्रिंट(is_prime(2))
#आउटपुट: प्राइम

प्रिंट(is_prime(9))
#आउटपुट: कम्पोजिट"
"def print_primes_without_five(lower, upper):
    # Step 1: Create a boolean array ""is_prime[0..upper]"" and initialize
    # all entries it as true.
    is_prime = [True] * (upper + 1)
    is_prime[0] = is_prime[1] = False

    # Step 2: Mark all the multiples of prime numbers starting from 2
    # as false.
    p = 2
    while p * p <= upper:
        if is_prime[p]:
            for i in range(p * p, upper + 1, p):
                is_prime[i] = False
        p += 1

    # Step 3: Print all prime numbers in the given range excluding
    # numbers containing the digit 5.
    for num in range(lower, upper + 1):
        if is_prime[num] and '5' not in str(num):
            print(num)","परिभाषा print_primes_without_five(छोटा, बड़ा):
    #चरण 1: एक बूलियन सरणी ""is_prime[0..upper]"" बनाएं और आरंभ करें
    #सभी प्रविष्टियों को सत्य मानें।
    is_prime = [सत्य] * (बड़ा + 1)
    is_prime[0] = is_prime[1] = असत्य

    #चरण 2: 2 से शुरू करके सभी अभाज्य संख्याओं के गुणजों को चिह्नित करें
    #झूठा है।
    पी = 2
    जबतक पी * पी <= बड़ा:
        यदि is_prime[पी]:
            के_लिए ई में रेंज(पी * पी, बड़ा + 1, पी):
                is_prime[ई] = असत्य
        पी += 1

    #चरण 3: दी गई श्रेणी में सभी अभाज्य संख्याओं को प्रिंट करें
    #अंक 5 वाली संख्याएँ.
    के_लिए संख्या में रेंज(छोटा, बड़ा + 1):
        यदि is_prime[संख्या] और '5' ना में स्ट्रिंग(संख्या):
            प्रिंट(संख्या)"
"import time

# Function to check if a number is prime
def is_prime(n):
    if n < 2:
        return False
    for i in range(2, int(n**0.5) + 1):
        if n % i == 0:
            return False
    return True

# Caching mechanism for prime numbers
prime_cache = {}

# Modified function to check if a number is prime using caching
def is_prime_cached(n):
    if n in prime_cache:
        return prime_cache[n]
    prime = is_prime(n)
    prime_cache[n] = prime
    return prime

# Timer function
def timer(func):
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f""Execution time: {end - start} seconds"")
        return result
    return wrapper

# List comprehension to generate the list of prime numbers
@timer
def generate_prime_palindromic_fibonacci():
    return [num for num in range(10000, 20001) if is_prime_cached(num) and str(num) == str(num)[::-1] and is_fibonacci(num)]

# Function to check if a number is a Fibonacci number
def is_fibonacci(n):
    a, b = 0, 1
    while b < n:
        a, b = b, a + b
    return b == n

# Test the function
primes = generate_prime_palindromic_fibonacci()
print(primes)","आयात समय

#कोई संख्या अभाज्य है या नहीं, यह जाँचने के लिए फ़ंक्शन
परिभाषा is_prime(एन):
    यदि एन < 2:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(एन**0.5) + 1):
        यदि एन % ई == 0:
            वापस असत्य
    वापस सत्य

#अभाज्य संख्याओं के लिए कैशिंग तंत्र
prime_cache = {}

#कैशिंग का उपयोग करके यह जांचने के लिए संशोधित फ़ंक्शन कि कोई संख्या अभाज्य है या नहीं
परिभाषा is_prime_cached(एन):
    यदि एन में prime_cache:
        वापस prime_cache[एन]
    मुख्य = is_prime(एन)
    prime_cache[एन] = मुख्य
    वापस मुख्य

#टाइमर फ़ंक्शन
परिभाषा घड़ी(समारोह):
    परिभाषा आवरण(*आर्ग, **क्वार्ग्स):
        शुरू = समय.समय()
        परिणाम = समारोह(*आर्ग, **क्वार्ग्स)
        अंत = समय.समय()
        प्रिंट(एफ""कार्यान्वयन समय: {अंत - शुरू} सेकंड"")
        वापस परिणाम
    वापस आवरण

#अभाज्य संख्याओं की सूची बनाने के लिए सूची समझ
@घड़ी
परिभाषा generate_prime_palindromic_fibonacci():
    वापस [संख्या के_लिए संख्या में रेंज(10000, 20001) यदि is_prime_cached(संख्या) और स्ट्रिंग(संख्या) == स्ट्रिंग(संख्या)[::-1] और is_fibonacci(संख्या)]

#यह जाँचने के लिए फ़ंक्शन कि कोई संख्या फिबोनाची संख्या है या नहीं
परिभाषा is_fibonacci(एन):
    ए, बी = 0, 1
    जबतक बी < एन:
        ए, बी = बी, ए + बी
    वापस बी == एन

#फ़ंक्शन का परीक्षण करें
अभाज्य = generate_prime_palindromic_fibonacci()
प्रिंट(अभाज्य)"
"import math

def average_list(lst):
    if not lst:
        return None
    
    if len(lst) == 1:
        return lst[0]
    
    total = 0
    count = 0
    
    for num in lst:
        if not isinstance(num, (int, float)):
            raise ValueError(""List contains non-numeric elements"")
        
        if isinstance(num, complex):
            raise ValueError(""List contains complex numbers"")
        
        if math.isnan(num):
            raise ValueError(""List contains NaN values"")
        
        if math.isinf(num):
            raise ValueError(""List contains infinity or negative infinity values"")
        
        if abs(num) > 1e308:
            raise ValueError(""List contains numbers that are too large"")
        
        total += num
        count += 1
    
    return total / count","आयात गणित

परिभाषा average_list(प्रथम):
    यदि ना प्रथम:
        वापस कोई नहीं

    यदि लंबाई(प्रथम) == 1:
        वापस प्रथम[0]

    कुल = 0
    गिनें = 0

    के_लिए संख्या में प्रथम:
        यदि ना उदाहरण_है(संख्या, (अंक, दश)):
            उठाओ मान_त्रुटि(""सूची रोकना गैर-संख्यात्मक तत्वों"")

        यदि उदाहरण_है(संख्या, समिश्र):
            उठाओ मान_त्रुटि(""सूची रोकना समिश्र नंबर"")

        यदि गणित.इस्नान(संख्या):
            उठाओ मान_त्रुटि(""सूची रोकना नेन मान"")

        यदि गणित.आइसिन्फ़(संख्या):
            उठाओ मान_त्रुटि(""सूची रोकना अनंत या नकारात्मक अनंत मान"")

        यदि निरपेक्ष_मान(संख्या) > 1ई308:
            उठाओ मान_त्रुटि(""सूची रोकना नंबर वह हैं बहुत बड़ा"")

        कुल += संख्या
        गिनें += 1

    वापस कुल / गिनें"
"import sqlite3

def delete_row(connection):
    try:
        # Start a transaction
        connection.execute(""BEGIN TRANSACTION"")

        # Execute the complex query
        cursor = connection.execute(""SELECT ..."")

        # Fetch the row to be deleted
        row = cursor.fetchone()

        if row:
            # Delete the row using its primary key
            connection.execute(""DELETE FROM table_name WHERE id=?"", (row['id'],))

        # Commit the transaction
        connection.execute(""COMMIT"")

        # Close the cursor
        cursor.close()

    except sqlite3.Error as error:
        # Rollback the transaction in case of any exception
        connection.execute(""ROLLBACK"")

        # Display the error message
        print(f""Error: {error}"")

    finally:
        # Close the database connection
        connection.close()

# Create a connection to the SQLite database
connection = sqlite3.connect(""database.db"")

# Call the function to delete the row
delete_row(connection)","आयात SQLite3

परिभाषा delete_row(कनेक्शन):
    प्रयत्न:
        #लेन-देन शुरू करें
        कनेक्शन.निष्पादित करना(""शुरू लेन-देन"")

        #जटिल क्वेरी निष्पादित करें
        कर्सर = कनेक्शन.निष्पादित करना(""चुनना ..."")

        #हटाई जाने वाली पंक्ति प्राप्त करें
        पंक्ति = कर्सर.फ़ेचऑन()

        यदि पंक्ति:
            #प्राथमिक कुंजी का उपयोग करके पंक्ति को हटाएं
            कनेक्शन.निष्पादित करना(""मिटाना से table_name कहाँ पहचान=?"", (पंक्ति['पहचान'],))

        #लेन-देन को प्रतिबद्ध करें
        कनेक्शन.निष्पादित करना(""प्रतिबद्ध"")

        #कर्सर बंद करें
        कर्सर.बंद()

    सिवाय SQLite3.गलती की_तरह गलती:
        #किसी भी अपवाद की स्थिति में लेनदेन को वापस ले लें
        कनेक्शन.निष्पादित करना(""रोलबैक"")

        #त्रुटि संदेश प्रदर्शित करें
        प्रिंट(एफ""गलती: {गलती}"")

    अंत_में:
        #डेटाबेस कनेक्शन बंद करें
        कनेक्शन.बंद()

#SQLite डेटाबेस से कनेक्शन बनाएँ
कनेक्शन = SQLite3.जोड़ना(""डेटाबेस.डाटाबेस"")

#पंक्ति को हटाने के लिए फ़ंक्शन को कॉल करें
delete_row(कनेक्शन)"
"import re

def extract_emails(string):
    # Use regular expression pattern to find all email addresses in the string
    pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'
    matches = re.findall(pattern, string)
    
    # Remove any duplicate email addresses
    unique_emails = list(set(matches))
    
    return unique_emails","आयात दोबारा

परिभाषा extract_emails(डोरी):
    #स्ट्रिंग में सभी ईमेल पते खोजने के लिए नियमित अभिव्यक्ति पैटर्न का उपयोग करें
    नमूना = आर'\बी[ए-ज़ा-जेड0-9._%+-]+@[ए-ज़ा-जेड0-9.-]+\.[ए-ज़ा-जेड]{2,}\बी'
    माचिस = दोबारा.सभी खोजें(नमूना, डोरी)

    #किसी भी डुप्लिकेट ईमेल पते को हटाएँ
    unique_emails = सूची(सेट(माचिस))

    वापस unique_emails"
"def clean_and_sort(lst):
   result = []
   for element in lst:
      if type(element) == int:
         result.append(element + 5)
   # implement your own sorting algorithm here
   n = len(result)
   for i in range(n):
      for j in range(0, n-i-1):
         if result[j] < result[j+1]:
            result[j], result[j+1] = result[j+1], result[j]
   return result

print(clean_and_sort([1, 2, ""hello""]))","परिभाषा clean_and_sort(प्रथम):
   परिणाम = []
   के_लिए तत्व में प्रथम:
      यदि प्रकार(तत्व) == अंक:
         परिणाम.संलग्न(तत्व + 5)
   #अपना स्वयं का सॉर्टिंग एल्गोरिदम यहां लागू करें
   एन = लंबाई(परिणाम)
   के_लिए ई में रेंज(एन):
      के_लिए जे में रेंज(0, एन-ई-1):
         यदि परिणाम[जे] < परिणाम[जे+1]:
            परिणाम[जे], परिणाम[जे+1] = परिणाम[जे+1], परिणाम[जे]
   वापस परिणाम

प्रिंट(clean_and_sort([1, 2, ""नमस्ते""]))"
"def is_valid_palindrome(s):
    # Convert the string to lowercase
    s = s.lower()
    
    # Initialize the two pointers
    left = 0
    right = len(s) - 1
    
    while left < right:
        # Check if the left character is not alphabetic
        if not s[left].isalpha():
            left += 1
            continue
        
        # Check if the right character is not alphabetic
        if not s[right].isalpha():
            right -= 1
            continue
        
        # Check if the characters at the two positions are equal
        if s[left] != s[right]:
            return False
        
        # Move the pointers towards the middle
        left += 1
        right -= 1
    
    return True","परिभाषा is_valid_palindrome(एस):
    #स्ट्रिंग को लोअरकेस में बदलें
    एस = एस.छोटा()

    #दो पॉइंटर्स को आरंभ करें
    बाएं = 0
    सही = लंबाई(एस) - 1

    जबतक बाएं < सही:
        #जाँचें कि क्या बायाँ अक्षर वर्णमाला में नहीं है
        यदि ना एस[बाएं].अक्षर_है():
            बाएं += 1
            जारी

        #जाँचें कि क्या सही अक्षर वर्णमाला में नहीं है
        यदि ना एस[सही].अक्षर_है():
            सही -= 1
            जारी

        #जाँच करें कि क्या दोनों स्थानों पर अक्षर समान हैं
        यदि एस[बाएं] != एस[सही]:
            वापस असत्य

        #पॉइंटर्स को मध्य की ओर ले जाएं
        बाएं += 1
        सही -= 1

    वापस सत्य"
"print(is_valid_palindrome(""racecar""))  # Output: True
print(is_valid_palindrome(""A man, a plan, a canal, Panama!""))  # Output: True
print(is_valid_palindrome(""hello world""))  # Output: False","प्रिंट(is_valid_palindrome(""रेसकार"")) #आउटपुट: सत्य
प्रिंट(is_valid_palindrome(""ए आदमी, ए योजना, ए नहर, पनामा!"")) #आउटपुट: सत्य
प्रिंट(is_valid_palindrome(""नमस्ते दुनिया"")) #आउटपुट: गलत"
"def is_palindrome(num):
    # Convert the number to string
    num_str = str(num)
    
    # Check if the number is positive
    if num <= 0:
        return False
    
    # Check if the number has at least 5 digits
    if len(num_str) < 5:
        return False
    
    # Check if the number consists of unique digits
    if len(set(num_str)) != len(num_str):
        return False
    
    # Check if the number is divisible by 7
    if num % 7 != 0:
        return False
    
    # Check if the number is a palindrome
    if num_str == num_str[::-1]:
        return True
    
    # Check for palindromic substrings within the number
    for i in range(len(num_str)):
        for j in range(i+2, len(num_str)+1):
            sub_num = num_str[i:j]
            if sub_num == sub_num[::-1]:
                return True
    
    return False

# Testing the script
# Decimal number
num_decimal = 12321
print(f""Is {num_decimal} a palindrome? {is_palindrome(num_decimal)}"")

# Hexadecimal number
num_hexadecimal = 0x12321
print(f""Is {num_hexadecimal} a palindrome? {is_palindrome(num_hexadecimal)}"")

# Other test cases
print(f""Is 12345 a palindrome? {is_palindrome(12345)}"")
print(f""Is 1234567 a palindrome? {is_palindrome(1234567)}"")
print(f""Is 12321 a palindrome? {is_palindrome(12321)}"")","परिभाषा is_palindrome(संख्या):
    #संख्या को स्ट्रिंग में बदलें
    num_str = स्ट्रिंग(संख्या)

    #जाँचें कि संख्या सकारात्मक है या नहीं
    यदि संख्या <= 0:
        वापस असत्य

    #जाँचें कि संख्या में कम से कम 5 अंक हैं या नहीं
    यदि लंबाई(num_str) < 5:
        वापस असत्य

    #जाँच करें कि संख्या में अद्वितीय अंक हैं या नहीं
    यदि लंबाई(सेट(num_str)) != लंबाई(num_str):
        वापस असत्य

    #जाँचें कि संख्या 7 से विभाज्य है या नहीं
    यदि संख्या % 7 != 0:
        वापस असत्य

    #जाँच करें कि क्या संख्या पैलिंड्रोम है
    यदि num_str == num_str[::-1]:
        वापस सत्य

    #संख्या के भीतर पैलिंड्रोमिक सबस्ट्रिंग की जाँच करें
    के_लिए ई में रेंज(लंबाई(num_str)):
        के_लिए जे में रेंज(ई+2, लंबाई(num_str)+1):
            sub_num = num_str[ई:जे]
            यदि sub_num == sub_num[::-1]:
                वापस सत्य

    वापस असत्य

#स्क्रिप्ट का परीक्षण
#दशमलव संख्या
num_decimal = 12321
प्रिंट(एफ""है {num_decimal} ए विलोमपद? {is_palindrome(num_decimal)}"")

#हेक्साडेसिमल संख्या
num_hexadecimal = 0एक्स12321
प्रिंट(एफ""है {num_hexadecimal} ए विलोमपद? {is_palindrome(num_hexadecimal)}"")

#अन्य परीक्षण मामले
प्रिंट(एफ""है 12345 ए विलोमपद? {is_palindrome(12345)}"")
प्रिंट(एफ""है 1234567 ए विलोमपद? {is_palindrome(1234567)}"")
प्रिंट(एफ""है 12321 ए विलोमपद? {is_palindrome(12321)}"")"
"import re

def remove_vowels(string):
    return re.sub(r'[aeiouAEIOU]', '', string)

def sort_characters(string):
    frequency = {}
    for char in string:
        frequency[char] = frequency.get(char, 0) + 1
    sorted_chars = sorted(frequency.keys(), key=lambda x: (-frequency[x], x))
    return sorted_chars

def remove_vowels_and_sort(string):
    string_without_vowels = remove_vowels(string)
    sorted_string = sort_characters(string_without_vowels)
    return ''.join(sorted_string)","आयात दोबारा

परिभाषा remove_vowels(डोरी):
    वापस दोबारा.उप(आर'[aeiouAEIOU]', '', डोरी)

परिभाषा sort_characters(डोरी):
    आवृत्ति = {}
    के_लिए चार में डोरी:
        आवृत्ति[चार] = आवृत्ति.पाना(चार, 0) + 1
    sorted_chars = क्रमबद्ध(आवृत्ति.कीज़(), चाबी=लैम्ब्डा एक्स: (-आवृत्ति[एक्स], एक्स))
    वापस sorted_chars

परिभाषा remove_vowels_and_sort(डोरी):
    string_without_vowels = remove_vowels(डोरी)
    sorted_string = sort_characters(string_without_vowels)
    वापस ''.जोड़(sorted_string)"
"input_string = ""Hello World""
output_string = remove_vowels_and_sort(input_string)
print(output_string)","input_string = ""नमस्ते दुनिया""
output_string = remove_vowels_and_sort(input_string)
प्रिंट(output_string)"
"def reverse_matrix(matrix):
    new_matrix = []
    for i in range(len(matrix)):
        new_matrix.append([])
        for j in range(len(matrix[i])):
            new_matrix[i].insert(0, matrix[i][j])
    return new_matrix


# Test case 1
matrix1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
# Expected output: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
print(reverse_matrix(matrix1))

# Test case 2
matrix2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
# Expected output: [[8, 7, 6, 5], [4, 3, 2, 1]]
print(reverse_matrix(matrix2))

# Test case 3
matrix3 = [[1, 2],
           [3, 4],
           [5, 6]]
# Expected output: [[6, 5], [4, 3], [2, 1]]
print(reverse_matrix(matrix3))","परिभाषा reverse_matrix(मैट्रिक्स):
    new_matrix = []
    के_लिए ई में रेंज(लंबाई(मैट्रिक्स)):
        new_matrix.संलग्न([])
        के_लिए जे में रेंज(लंबाई(मैट्रिक्स[ई])):
            new_matrix[ई].डाल(0, मैट्रिक्स[ई][जे])
    वापस new_matrix


#परीक्षण मामला 1
मैट्रिक्स1 = [[1, 2, 3],
           [4, 5, 6],
           [7, 8, 9]]
#अपेक्षित आउटपुट: [[9, 8, 7], [6, 5, 4], [3, 2, 1]]
प्रिंट(reverse_matrix(मैट्रिक्स1))

#परीक्षण मामला 2
मैट्रिक्स2 = [[1, 2, 3, 4],
           [5, 6, 7, 8]]
#अपेक्षित आउटपुट: [[8, 7, 6, 5], [4, 3, 2, 1]]
प्रिंट(reverse_matrix(मैट्रिक्स2))

#परीक्षण मामला 3
मैट्रिक्स3 = [[1, 2],
           [3, 4],
           [5, 6]]
#अपेक्षित आउटपुट: [[6, 5], [4, 3], [2, 1]]
प्रिंट(reverse_matrix(मैट्रिक्स3))"
"def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)

# Example usage
n = 10
fibonacci_number = fibonacci(n)
print(f""The Fibonacci number at index {n} is {fibonacci_number}."")","परिभाषा फाइबोनैचि(एन):
    यदि एन == 0:
        वापस 0
    वरना_यदि एन == 1:
        वापस 1
    वरना:
        वापस फाइबोनैचि(एन-1) + फाइबोनैचि(एन-2)

#उपयोग का उदाहरण
एन = 10
fibonacci_number = फाइबोनैचि(एन)
प्रिंट(एफ"" फाइबोनैचि संख्या पर सूचक {एन} है {fibonacci_number}."")"
"def count_unique_consonants(string):
    consonants = set()
    lowercase_string = string.lower()
    for char in lowercase_string:
        if char.isalpha() and char not in 'aeiou':
            consonants.add(char)
    return len(consonants)","परिभाषा count_unique_consonants(डोरी):
    व्यंजन = सेट()
    lowercase_string = डोरी.छोटा()
    के_लिए चार में lowercase_string:
        यदि चार.अक्षर_है() और चार ना में 'ऐइयो':
            व्यंजन.योग(चार)
    वापस लंबाई(व्यंजन)"
"print(count_unique_consonants(""ApplE""))  # Output: 2
print(count_unique_consonants(""MissiSsippi""))  # Output: 2","प्रिंट(count_unique_consonants(""सेब"")) #आउटपुट: 2
प्रिंट(count_unique_consonants(""मिसिसिपी"")) #आउटपुट: 2"
"def filter_and_replace(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    filtered_words = []
    
    words = string.split()
    
    for word in words:
        if any(char.isdigit() or not char.isalpha() for char in word):
            continue
        
        if len(word) > 3 and any(char in vowels for char in word):
            filtered_word = """"
            for char in word:
                if char in vowels:
                    vowel_index = vowels.index(char)
                    next_vowel = vowels[(vowel_index + 1) % len(vowels)]
                    filtered_word += next_vowel
                else:
                    filtered_word += char
            filtered_words.append(filtered_word)
    
    return "" "".join(filtered_words)


# Example usage:
input_string = ""Hello world! This is a test string. Filter me out if I contain numbers or special characters.""
output_string = filter_and_replace(input_string)
print(output_string)","परिभाषा filter_and_replace(डोरी):
    स्वर = ['ए', 'ई', 'ई', 'हे', 'यू']
    filtered_words = []

    शब्द = डोरी.बाँट()

    के_लिए शब्द में शब्द:
        यदि कोई(चार.अंक_है() या ना चार.अक्षर_है() के_लिए चार में शब्द):
            जारी

        यदि लंबाई(शब्द) > 3 और कोई(चार में स्वर के_लिए चार में शब्द):
            filtered_word = """"
            के_लिए चार में शब्द:
                यदि चार में स्वर:
                    vowel_index = स्वर.सूचक(चार)
                    next_vowel = स्वर[(vowel_index + 1) % लंबाई(स्वर)]
                    filtered_word += next_vowel
                वरना:
                    filtered_word += चार
            filtered_words.संलग्न(filtered_word)

    वापस "" "".जोड़(filtered_words)


#उदाहरण उपयोग:
input_string = ""नमस्ते दुनिया! यह है ए परीक्षा डोरी. फ़िल्टर मुझे बाहर यदि मैं रोकना नंबर या विशेष वर्ण.""
output_string = filter_and_replace(input_string)
प्रिंट(output_string)"
"def isOddPrimeGreaterThan100(number):
    if number <= 100 or number % 2 == 0:  # Check if number is less than or equal to 100 or even
        return False
    for i in range(3, int(number**0.5) + 1, 2):  # Check divisibility by odd numbers only
        if number % i == 0:
            return False
    return True

def findSecondSmallestOddPrimeGreaterThan100(array):
    smallest = secondSmallest = float('inf')
    for number in array:
        if isOddPrimeGreaterThan100(number):
            if number < smallest:
                secondSmallest = smallest
                smallest = number
            elif number < secondSmallest:
                secondSmallest = number
    return secondSmallest","परिभाषा isOddPrimeGreaterThan100(संख्या):
    यदि संख्या <= 100 या संख्या % 2 == 0: #जाँचें कि संख्या 100 से कम या बराबर है या सम
        वापस असत्य
    के_लिए ई में रेंज(3, अंक(संख्या**0.5) + 1, 2): #केवल विषम संख्याओं से विभाज्यता की जाँच करें
        यदि संख्या % ई == 0:
            वापस असत्य
    वापस सत्य

परिभाषा दूसरासबसे छोटा, अजीब, प्राइम, ग्रेटर थान ढूंढें100(सरणी):
    सबसे छोटा = दूसरासबसे छोटा = दश('जानकारी')
    के_लिए संख्या में सरणी:
        यदि isOddPrimeGreaterThan100(संख्या):
            यदि संख्या < सबसे छोटा:
                दूसरासबसे छोटा = सबसे छोटा
                सबसे छोटा = संख्या
            वरना_यदि संख्या < दूसरासबसे छोटा:
                दूसरासबसे छोटा = संख्या
    वापस दूसरासबसे छोटा"
"array = [101, 103, 105, 107, 109, 111, 113, 115, 117, 119]
secondSmallest = findSecondSmallestOddPrimeGreaterThan100(array)
print(secondSmallest)  # Output: 105","सरणी = [101, 103, 105, 107, 109, 111, 113, 115, 117, 119]
दूसरासबसे छोटा = दूसरासबसे छोटा, अजीब, प्राइम, ग्रेटर थान ढूंढें100(सरणी)
प्रिंट(दूसरासबसे छोटा) #आउटपुट: 105"
"class SeparatorNotFoundError(Exception):
    pass

class MultipleSeparatorsError(Exception):
    pass

try:
    mystring = ""Hello, World!""
    separator = ""#""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator, 1)
    if not split_string:
        raise SeparatorNotFoundError(""Separator not found in string"")

    # Additional Requirement:
    # If the separator is found more than once in the string, raise a custom exception called ""MultipleSeparatorsError""

    # Incorrect way to split the string on a separator
    split_string = mystring.split(separator)
    if len(split_string) > 2:
        raise MultipleSeparatorsError(""Multiple separators found in string"")

except SeparatorNotFoundError as e:
    print(""Error:"", e)

except MultipleSeparatorsError as e:
    print(""Error:"", e)

except Exception as e:
    print(""Error:"", e)","वर्ग विभाजकनहींमिलात्रुटि(अपवाद):
    जाने_दो

वर्ग मल्टिपलसेपरेटर्सत्रुटि(अपवाद):
    जाने_दो

प्रयत्न:
    माईस्ट्रिंग = ""नमस्ते, दुनिया!""
separator = ""#""

    #विभाजक पर स्ट्रिंग को विभाजित करने का गलत तरीका
    split_string = माईस्ट्रिंग.बाँट(सेपरेटर, 1)
    यदि ना split_string:
        उठाओ विभाजकनहींमिलात्रुटि(""सेपरेटर ना मिला में डोरी"")

    #अतिरिक्त मांग:
    #यदि स्ट्रिंग में विभाजक एक से अधिक बार पाया जाता है, तो ""MultipleSeparatorsError"" नामक एक कस्टम अपवाद उठाएं

    #विभाजक पर स्ट्रिंग को विभाजित करने का गलत तरीका
    split_string = माईस्ट्रिंग.बाँट(सेपरेटर)
    यदि लंबाई(split_string) > 2:
        उठाओ मल्टिपलसेपरेटर्सत्रुटि(""विभिन्न विभाजक मिला में डोरी"")

सिवाय विभाजकनहींमिलात्रुटि की_तरह ई:
    प्रिंट(""गलती:"", ई)

सिवाय मल्टिपलसेपरेटर्सत्रुटि की_तरह ई:
    प्रिंट(""गलती:"", ई)

सिवाय अपवाद की_तरह ई:
    प्रिंट(""गलती:"", ई)"
"def create_index_dictionary(list_one, list_two):
    if len(list_one) != len(list_two):
        raise ValueError(""Input lists must be of equal length"")
    
    index_dict = {}
    for i in range(len(list_one)):
        if isinstance(list_one[i], (list, dict, tuple)) and isinstance(list_two[i], (list, dict, tuple)):
            if isinstance(list_one[i], set) or isinstance(list_two[i], set):
                raise ValueError(""Input lists cannot contain sets"")
            
            nested_dict = {}
            if isinstance(list_one[i], dict) and isinstance(list_two[i], dict):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested dictionaries must have the same number of elements"")
                
                for key in list_one[i].keys():
                    if key not in list_two[i]:
                        raise ValueError(""Keys in nested dictionaries must be the same"")
                    nested_dict[key] = (list_one[i][key], list_two[i][key])
            elif isinstance(list_one[i], list) and isinstance(list_two[i], list):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Nested lists must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            elif isinstance(list_one[i], tuple) and isinstance(list_two[i], tuple):
                if len(list_one[i]) != len(list_two[i]):
                    raise ValueError(""Tuples must have the same length"")
                
                for j in range(len(list_one[i])):
                    nested_dict[j] = (list_one[i][j], list_two[i][j])
            
            index_dict[i] = nested_dict
        else:
            index_dict[i] = (list_one[i], list_two[i])
    
    return index_dict","परिभाषा create_index_dictionary(list_one, list_two):
    यदि लंबाई(list_one) != लंबाई(list_two):
        उठाओ मान_त्रुटि(""इनपुट सूचियों अवश्य होना का बराबर लंबाई"")

    index_dict = {}
    के_लिए ई में रेंज(लंबाई(list_one)):
        यदि उदाहरण_है(list_one[ई], (सूची, कोश, ट्यूपल)) और उदाहरण_है(list_two[ई], (सूची, कोश, ट्यूपल)):
            यदि उदाहरण_है(list_one[ई], सेट) या उदाहरण_है(list_two[ई], सेट):
                उठाओ मान_त्रुटि(""इनपुट सूचियों नही सकता रोकना सेट"")

            nested_dict = {}
            यदि उदाहरण_है(list_one[ई], कोश) और उदाहरण_है(list_two[ई], कोश):
                यदि लंबाई(list_one[ई]) != लंबाई(list_two[ई]):
                    उठाओ मान_त्रुटि(""नेस्टेड शब्दकोश: अवश्य पास होना  वही संख्या का तत्वों"")

                के_लिए चाबी में list_one[ई].कीज़():
                    यदि चाबी ना में list_two[ई]:
                        उठाओ मान_त्रुटि(""कुंजियाँ में नेस्ट शब्दकोश: अवश्य होना  वही"")
                    nested_dict[चाबी] = (list_one[ई][चाबी], list_two[ई][चाबी])
            वरना_यदि उदाहरण_है(list_one[ई], सूची) और उदाहरण_है(list_two[ई], सूची):
                यदि लंबाई(list_one[ई]) != लंबाई(list_two[ई]):
                    उठाओ मान_त्रुटि(""नेस्टेड सूचियों अवश्य पास होना  वही लंबाई"")

                के_लिए जे में रेंज(लंबाई(list_one[ई])):
                    nested_dict[जे] = (list_one[ई][जे], list_two[ई][जे])
            वरना_यदि उदाहरण_है(list_one[ई], ट्यूपल) और उदाहरण_है(list_two[ई], ट्यूपल):
                यदि लंबाई(list_one[ई]) != लंबाई(list_two[ई]):
                    उठाओ मान_त्रुटि(""ट्यूपल्स अवश्य पास होना  वही लंबाई"")

                के_लिए जे में रेंज(लंबाई(list_one[ई])):
                    nested_dict[जे] = (list_one[ई][जे], list_two[ई][जे])

            index_dict[ई] = nested_dict
        वरना:
            index_dict[ई] = (list_one[ई], list_two[ई])

    वापस index_dict"
"def find_maximum(a, b, c):
    # Convert the numbers to binary
    a_bin = bin(a)
    b_bin = bin(b)
    c_bin = bin(c)
    
    # Count the number of 1s in the binary representation of each number
    a_count = a_bin.count('1')
    b_count = b_bin.count('1')
    c_count = c_bin.count('1')
    
    # Compare the counts to find the maximum
    if a_count > b_count and a_count > c_count:
        return a
    elif b_count > a_count and b_count > c_count:
        return b
    else:
        return c","परिभाषा find_maximum(ए, बी, सी):
    #संख्याओं को बाइनरी में बदलें
    a_bin = द्वि(ए)
    b_bin = द्वि(बी)
    c_bin = द्वि(सी)

    #प्रत्येक संख्या के बाइनरी निरूपण में 1 की संख्या गिनें
    a_count = a_bin.गिनें('1')
    b_count = b_bin.गिनें('1')
    c_count = c_bin.गिनें('1')

    #अधिकतम ज्ञात करने के लिए गणनाओं की तुलना करें
    यदि a_count > b_count और a_count > c_count:
        वापस ए
    वरना_यदि b_count > a_count और b_count > c_count:
        वापस बी
    वरना:
        वापस सी"
"def quick_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    else:
        pivot = arr[0]
        less = [x for x in arr[1:] if x <= pivot]
        greater = [x for x in arr[1:] if x > pivot]
        sorted_less, comparisons_less = quick_sort(less)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(arr) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [pivot] + sorted_less
        return sorted_arr, comparisons

# Testing the code
arr = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, comparisons = quick_sort(arr)
print(""Sorted Array:"", sorted_arr)
print(""Number of Comparisons:"", comparisons)","परिभाषा quick_sort(आगमन):
    यदि लंबाई(आगमन) <= 1:
        वापस आगमन, 0
    वरना:
        धुरी = आगमन[0]
        कम = [एक्स के_लिए एक्स में आगमन[1:] यदि एक्स <= धुरी]
        ग्रेटर = [एक्स के_लिए एक्स में आगमन[1:] यदि एक्स > धुरी]
        sorted_less, comparisons_less = quick_sort(कम)
        sorted_greater, comparisons_greater = quick_sort(ग्रेटर)
        तुलना = लंबाई(आगमन) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [धुरी] + sorted_less
        वापस sorted_arr, तुलना

#कोड का परीक्षण
आगमन = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, तुलना = quick_sort(आगमन)
प्रिंट(""क्रमबद्ध सरणी:"", sorted_arr)
प्रिंट(""संख्या का तुलना:"", तुलना)"
"def quick_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    else:
        pivot = arr[1]  # Bug: Always select the second element as pivot
        less = [x for x in arr[1:] if x <= pivot]
        greater = [x for x in arr[1:] if x > pivot]
        sorted_less, comparisons_less = quick_sort(less)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(arr) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [pivot] + sorted_less
        return sorted_arr, comparisons

# Testing the code
arr = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, comparisons = quick_sort(arr)
print(""Sorted Array:"", sorted_arr)
print(""Number of Comparisons:"", comparisons)","परिभाषा quick_sort(आगमन):
    यदि लंबाई(आगमन) <= 1:
        वापस आगमन, 0
    वरना:
        धुरी = आगमन[1] #बग: हमेशा दूसरे तत्व को पिवट के रूप में चुनें
        कम = [एक्स के_लिए एक्स में आगमन[1:] यदि एक्स <= धुरी]
        ग्रेटर = [एक्स के_लिए एक्स में आगमन[1:] यदि एक्स > धुरी]
        sorted_less, comparisons_less = quick_sort(कम)
        sorted_greater, comparisons_greater = quick_sort(ग्रेटर)
        तुलना = लंबाई(आगमन) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [धुरी] + sorted_less
        वापस sorted_arr, तुलना

#कोड का परीक्षण
आगमन = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, तुलना = quick_sort(आगमन)
प्रिंट(""क्रमबद्ध सरणी:"", sorted_arr)
प्रिंट(""संख्या का तुलना:"", तुलना)"
"def quick_sort(arr):
    if len(arr) <= 1:
        return arr, 0
    else:
        pivot = arr[0]
        less = [x for x in arr if x < pivot]  # Bug: Include only elements less than the pivot
        greater = [x for x in arr if x > pivot]  # Bug: Include only elements greater than the pivot
        sorted_less, comparisons_less = quick_sort(less)
        sorted_greater, comparisons_greater = quick_sort(greater)
        comparisons = len(arr) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [pivot] + sorted_less
        return sorted_arr, comparisons

# Testing the code
arr = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, comparisons = quick_sort(arr)
print(""Sorted Array:"", sorted_arr)
print(""Number of Comparisons:"", comparisons)","परिभाषा quick_sort(आगमन):
    यदि लंबाई(आगमन) <= 1:
        वापस आगमन, 0
    वरना:
        धुरी = आगमन[0]
        कम = [एक्स के_लिए एक्स में आगमन यदि एक्स < धुरी] #बग: केवल पिवट से कम तत्वों को शामिल करें
        ग्रेटर = [एक्स के_लिए एक्स में आगमन यदि एक्स > धुरी] #बग: केवल पिवट से बड़े तत्वों को ही शामिल करें
        sorted_less, comparisons_less = quick_sort(कम)
        sorted_greater, comparisons_greater = quick_sort(ग्रेटर)
        तुलना = लंबाई(आगमन) - 1 + comparisons_less + comparisons_greater
        sorted_arr = sorted_greater + [धुरी] + sorted_less
        वापस sorted_arr, तुलना

#कोड का परीक्षण
आगमन = [5, 3, 9, 5, 2, 8, 4]
sorted_arr, तुलना = quick_sort(आगमन)
प्रिंट(""क्रमबद्ध सरणी:"", sorted_arr)
प्रिंट(""संख्या का तुलना:"", तुलना)"
"def calculate_distance(point1, point2):
    distance = ((point2[0] - point1[0])**2 + (point2[1] - point1[1])**2 + (point2[2] - point1[2])**2) ** 0.5
    return distance","परिभाषा calculate_distance(बिंदु1, बिंदु2):
    दूरी = ((बिंदु2[0] - बिंदु1[0])**2 + (बिंदु2[1] - बिंदु1[1])**2 + (बिंदु2[2] - बिंदु1[2])**2) ** 0.5
    वापस दूरी"
"import datetime

def get_current_date_time():
    now = datetime.datetime.now()
    iso_format = now.strftime(""%Y-%m-%dT%H:%M:%S%z"")
    day_of_week = now.strftime(""%A"")
    return iso_format, day_of_week

def calculate_days_between_dates(start_date, end_date):
    try:
        start_date = datetime.datetime.strptime(start_date, ""%Y-%m-%d"")
        end_date = datetime.datetime.strptime(end_date, ""%Y-%m-%d"")
        days = abs((end_date - start_date).days)
        return days
    except ValueError:
        return ""Invalid date format. Please use YYYY-MM-DD.""

# Print current date and time in ISO format with timezone offset and day of the week
iso_format, day_of_week = get_current_date_time()
print(""Current date and time (ISO format):"", iso_format)
print(""Day of the week:"", day_of_week)

# Calculate the number of days between two dates
start_date = input(""Enter the start date (YYYY-MM-DD): "")
end_date = input(""Enter the end date (YYYY-MM-DD): "")
days_between = calculate_days_between_dates(start_date, end_date)
print(""Number of days between the two dates:"", days_between)","आयात दिनांक समय

परिभाषा get_current_date_time():
    अब = दिनांक समय.दिनांक समय.अब()
    iso_format = अब.स्ट्रफटाइम(""%य-%एम-%डीटी%एच:%एम:%एस%जेड"")
    day_of_week = अब.स्ट्रफटाइम(""%ए"")
    वापस iso_format, day_of_week

परिभाषा calculate_days_between_dates(start_date, end_date):
    प्रयत्न:
        start_date = दिनांक समय.दिनांक समय.स्ट्रिपटाइम(start_date, ""%य-%एम-%डी"")
        end_date = दिनांक समय.दिनांक समय.स्ट्रिपटाइम(end_date, ""%य-%एम-%डी"")
        दिन = निरपेक्ष_मान((end_date - start_date).दिन)
        वापस दिन
    सिवाय मान_त्रुटि:
        वापस ""अमान्य तारीख प्रारूप. कृपया उपयोग वर्ष-मिमी-डीडी.""

#वर्तमान दिनांक और समय को ISO प्रारूप में समयक्षेत्र ऑफसेट और सप्ताह के दिन के साथ प्रिंट करें
iso_format, day_of_week = get_current_date_time()
प्रिंट(""मौजूदा तारीख और समय (आईएसओ प्रारूप):"", iso_format)
प्रिंट(""दिन का  सप्ताह:"", day_of_week)

#दो तिथियों के बीच दिनों की संख्या की गणना करें
start_date = इनपुट(""प्रवेश करना  शुरू तारीख (वर्ष-मिमी-डीडी): "")
end_date = इनपुट(""प्रवेश करना  अंत तारीख (वर्ष-मिमी-डीडी): "")
days_between = calculate_days_between_dates(start_date, end_date)
प्रिंट(""संख्या का दिन बीच में  दो खजूर:"", days_between)"
"def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr

arr = [10, 2, 7, 8, 32, 4, 8, 7, 10, 2]
sorted_arr = bubble_sort(arr)
print(sorted_arr)","परिभाषा bubble_sort(आगमन):
    एन = लंबाई(आगमन)
    के_लिए ई में रेंज(एन):
        के_लिए जे में रेंज(एन - 1 - ई):
            यदि आगमन[जे] > आगमन[जे + 1]:
                आगमन[जे], आगमन[जे + 1] = आगमन[जे + 1], आगमन[जे]
    वापस आगमन

आगमन = [10, 2, 7, 8, 32, 4, 8, 7, 10, 2]
sorted_arr = bubble_sort(आगमन)
प्रिंट(sorted_arr)"
"import math

def calculate_standard_deviation(numbers):
    if len(numbers) < 2:
        raise ValueError(""Standard deviation requires at least two data points."")
    
    mean = sum(numbers) / len(numbers)
    squared_diff_sum = 0
    
    for num in numbers:
        squared_diff_sum += (num - mean) ** 2
    
    variance = squared_diff_sum / (len(numbers) - 1)
    standard_deviation = math.sqrt(variance)
    
    return standard_deviation

# Example usage
numbers = [1, 2, 3, 4, 5]
try:
    std_dev = calculate_standard_deviation(numbers)
    print(""Standard Deviation:"", std_dev)
except ValueError as e:
    print(e)","आयात गणित

परिभाषा calculate_standard_deviation(नंबर):
    यदि लंबाई(नंबर) < 2:
        उठाओ मान_त्रुटि(""मानक विचलन आवश्यक है पर कम से कम दो डेटा अंक."")

    अर्थ = योग(नंबर) / लंबाई(नंबर)
    squared_diff_sum = 0

    के_लिए संख्या में नंबर:
        squared_diff_sum += (संख्या - अर्थ) ** 2

    झगड़ा = squared_diff_sum / (लंबाई(नंबर) - 1)
    standard_deviation = गणित.एसक्यूआरटी(झगड़ा)

    वापस standard_deviation

#उपयोग का उदाहरण
नंबर = [1, 2, 3, 4, 5]
प्रयत्न:
    std_dev = calculate_standard_deviation(नंबर)
    प्रिंट(""मानक विचलन:"", std_dev)
सिवाय मान_त्रुटि की_तरह ई:
    प्रिंट(ई)"
"import random

def generate_dictionary(n):
    dictionary = {}
    
    # Generate a list of unique random strings as keys
    keys = set()
    while len(keys) < n:
        key = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=10))
        keys.add(key)
    
    # Generate key-value pairs with random values
    for key in keys:
        value = random.randint(1, 1000)
        dictionary[key] = value
    
    # Sort the dictionary by values in descending order
    sorted_dict = {k: v for k, v in sorted(dictionary.items(), key=lambda item: item[1], reverse=True)}
    
    return sorted_dict

# Generate a dictionary with 1000 key-value pairs
dictionary = generate_dictionary(1000)

# Print the dictionary
for key, value in dictionary.items():
    print(key, value)","आयात यादृच्छिक

परिभाषा generate_dictionary(एन):
    शब्दकोष = {}

    #कुंजी के रूप में अद्वितीय यादृच्छिक स्ट्रिंग की सूची बनाएं
    कीज़ = सेट()
    जबतक लंबाई(कीज़) < एन:
        चाबी = ''.जोड़(यादृच्छिक.विकल्प('abcdefghijklmnopqrstuvwxyz', के=10))
        कीज़.योग(चाबी)

    #यादृच्छिक मानों के साथ कुंजी-मान युग्म उत्पन्न करें
    के_लिए चाबी में कीज़:
        कीमत = यादृच्छिक.रैंडिंट(1, 1000)
        शब्दकोष[चाबी] = कीमत

    #शब्दकोश को मानों के आधार पर अवरोही क्रम में क्रमबद्ध करें
    sorted_dict = {के: वी के_लिए के, वी में क्रमबद्ध(शब्दकोष.सामान(), चाबी=लैम्ब्डा वस्तु: वस्तु[1], उलट=सत्य)}

    वापस sorted_dict

#1000 कुंजी-मान युग्मों वाला शब्दकोश तैयार करें
शब्दकोष = generate_dictionary(1000)

#शब्दकोश प्रिंट करें
के_लिए चाबी, कीमत में शब्दकोष.सामान():
    प्रिंट(चाबी, कीमत)"
"def partition(arr, low, high):
    i = low - 1
    pivot = arr[high]

    for j in range(low, high):
        if arr[j] <= pivot:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]
    
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1


def quickselect(arr, low, high, k):
    if low == high:
        return arr[low]
    
    pivot_index = partition(arr, low, high)
    if k == pivot_index:
        return arr[k]
    elif k < pivot_index:
        return quickselect(arr, low, pivot_index - 1, k)
    else:
        return quickselect(arr, pivot_index + 1, high, k)


def median(arr):
    n = len(arr)
    if n % 2 == 1:
        return quickselect(arr, 0, n - 1, n // 2)
    else:
        return (quickselect(arr, 0, n - 1, n // 2) + quickselect(arr, 0, n - 1, n // 2 - 1)) / 2


# Example usage:
arr = [9, 2, 7, 4, 5, 8, 1, 6, 3]
print(""Array:"", arr)
print(""Median:"", median(arr))","परिभाषा विभाजन(आगमन, कम, उच्च):
    ई = कम - 1
    धुरी = आगमन[उच्च]

    के_लिए जे में रेंज(कम, उच्च):
        यदि आगमन[जे] <= धुरी:
            ई = ई + 1
            आगमन[ई], आगमन[जे] = आगमन[जे], आगमन[ई]

    आगमन[ई + 1], आगमन[उच्च] = आगमन[उच्च], आगमन[ई + 1]
    वापस ई + 1


परिभाषा त्वरित चयन(आगमन, कम, उच्च, के):
    यदि कम == उच्च:
        वापस आगमन[कम]

    pivot_index = विभाजन(आगमन, कम, उच्च)
    यदि के == pivot_index:
        वापस आगमन[के]
    वरना_यदि के < pivot_index:
        वापस त्वरित चयन(आगमन, कम, pivot_index - 1, के)
    वरना:
        वापस त्वरित चयन(आगमन, pivot_index + 1, उच्च, के)


परिभाषा MEDIAN(आगमन):
    एन = लंबाई(आगमन)
    यदि एन % 2 == 1:
        वापस त्वरित चयन(आगमन, 0, एन - 1, एन // 2)
    वरना:
        वापस (त्वरित चयन(आगमन, 0, एन - 1, एन // 2) + त्वरित चयन(आगमन, 0, एन - 1, एन // 2 - 1)) / 2


#उदाहरण उपयोग:
आगमन = [9, 2, 7, 4, 5, 8, 1, 6, 3]
प्रिंट(""सरणी:"", आगमन)
प्रिंट(""मंझला:"", MEDIAN(आगमन))"
"def access_nth_from_end(head, n):
    fast = head
    slow = head

    # Move the fast pointer n positions forward
    for _ in range(n):
        fast = fast.next

    # Check if the fast pointer reaches the end of the linked list
    if fast is None:
        return None  # Or raise an error

    # Move both pointers simultaneously until the fast pointer reaches the end
    while fast.next is not None:
        fast = fast.next
        slow = slow.next

    # Return the value of the node pointed to by the slow pointer
    return slow.value","परिभाषा access_nth_from_end(सिर, एन):
    तेज़ = सिर
    धीमा = सिर

    #तेज़ पॉइंटर को n स्थिति आगे ले जाएँ
    के_लिए _ में रेंज(एन):
        तेज़ = तेज़.अगला

    #जाँच करें कि क्या तेज़ पॉइंटर लिंक्ड सूची के अंत तक पहुँचता है
    यदि तेज़ है कोई नहीं:
        वापस कोई नहीं #या कोई त्रुटि उठाएं

    #दोनों पॉइंटर्स को एक साथ तब तक घुमाएँ जब तक कि तेज़ पॉइंटर अंत तक न पहुँच जाए
    जबतक तेज़.अगला है ना कोई नहीं:
        तेज़ = तेज़.अगला
        धीमा = धीमा.अगला

    #धीमे पॉइंटर द्वारा इंगित नोड का मान लौटाएँ
    वापस धीमा.कीमत"
"import psycopg2
from psycopg2 import OperationalError
from psycopg2.pool import SimpleConnectionPool

# Database connection details
username = ""john""
password = ""john123""
ip = ""100.10.0.10""
port = 5432
database = ""your_database_name""

# Connection pool settings
min_connections = 1
max_connections = 5

# SSL/TLS settings
sslmode = ""require""
sslrootcert = ""/path/to/root.crt""  # Path to your root certificate file
sslcert = ""/path/to/client.crt""  # Path to your client certificate file
sslkey = ""/path/to/client.key""  # Path to your client key file

# Create a connection pool
connection_pool = SimpleConnectionPool(min_connections, max_connections,
                                       host=ip, port=port, user=username, password=password,
                                       database=database, sslmode=sslmode, sslrootcert=sslrootcert,
                                       sslcert=sslcert, sslkey=sslkey)

def get_connection():
    # Try to get a connection from the pool
    connection = connection_pool.getconn()
    
    # If the connection is None, it means the pool is full, so wait and try again
    while connection is None:
        connection = connection_pool.getconn()
    
    return connection

def release_connection(connection):
    # Release the connection back to the pool
    connection_pool.putconn(connection)

def execute_query(query, params=None):
    try:
        # Get a connection from the pool
        connection = get_connection()
        
        # Create a cursor
        cursor = connection.cursor()
        
        # Execute the query
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        
        # Commit the transaction
        connection.commit()
        
        # Close the cursor
        cursor.close()
        
        # Release the connection back to the pool
        release_connection(connection)
        
    except (OperationalError, Exception) as e:
        # Handle database errors and exceptions
        if connection:
            connection.rollback()
            release_connection(connection)
        raise e

def main():
    try:
        # Example query
        query = ""SELECT * FROM your_table""
        
        # Execute the query
        execute_query(query)
        
        # Handle other operations...
        
    except (OperationalError, Exception) as e:
        # Log and handle the error gracefully
        print(""An error occurred:"", str(e))
        # Add error logging and handling mechanisms here

if __name__ == ""__main__"":
    main()","आयात साइकोपीजी2
से साइकोपीजी2 आयात परिचालनत्रुटि
से साइकोपीजी2.पूल आयात सरल कनेक्शन पूल

#डेटाबेस कनेक्शन विवरण
उपयोगकर्ता नाम = ""जॉन""
पासवर्ड = ""जॉन123""
आई पी = ""100.10.0.10""
पत्तन = 5432
डेटाबेस = ""your_database_name""

#कनेक्शन पूल सेटिंग्स
min_connections = 1
max_connections = 5

#SSL/TLS सेटिंग्स
एसएसएलमोड = ""ज़रूरत होना""
एसएसएलरूटसर्टिफिकेट = ""/पथ/को/जड़.सीआरटी"" #आपकी रूट प्रमाणपत्र फ़ाइल का पथ
एसएसएलसर्ट = ""/पथ/को/ग्राहक.सीआरटी"" #आपकी क्लाइंट प्रमाणपत्र फ़ाइल का पथ
एसएसएलकी = ""/पथ/को/ग्राहक.चाबी"" #आपकी क्लाइंट कुंजी फ़ाइल का पथ

#कनेक्शन पूल बनाएं
connection_pool = सरल कनेक्शन पूल(min_connections, max_connections,
                                       मेज़बान=आई पी, पत्तन=पत्तन, उपयोगकर्ता=उपयोगकर्ता नाम, पासवर्ड=पासवर्ड,
                                       डेटाबेस=डेटाबेस, एसएसएलमोड=एसएसएलमोड, एसएसएलरूटसर्टिफिकेट=एसएसएलरूटसर्टिफिकेट,
                                       एसएसएलसर्ट=एसएसएलसर्ट, एसएसएलकी=एसएसएलकी)

परिभाषा get_connection():
    #पूल से कनेक्शन प्राप्त करने का प्रयास करें
    कनेक्शन = connection_pool.गेटकॉन()

    #यदि कनेक्शन None है, तो इसका मतलब है कि पूल भर गया है, इसलिए प्रतीक्षा करें और पुनः प्रयास करें
    जबतक कनेक्शन है कोई नहीं:
        कनेक्शन = connection_pool.गेटकॉन()

    वापस कनेक्शन

परिभाषा release_connection(कनेक्शन):
    #कनेक्शन को वापस पूल में छोड़ दें
    connection_pool.पुटकॉन(कनेक्शन)

परिभाषा execute_query(सवाल, पैरामीटर=कोई नहीं):
    प्रयत्न:
        #पूल से कनेक्शन प्राप्त करें
        कनेक्शन = get_connection()

        #कर्सर बनाएं
        कर्सर = कनेक्शन.कर्सर()

        #क्वेरी निष्पादित करें
        यदि पैरामीटर:
            कर्सर.निष्पादित करना(सवाल, पैरामीटर)
        वरना:
            कर्सर.निष्पादित करना(सवाल)

        #लेन-देन को प्रतिबद्ध करें
        कनेक्शन.प्रतिबद्ध()

        #कर्सर बंद करें
        कर्सर.बंद()

        #कनेक्शन को वापस पूल में छोड़ दें
        release_connection(कनेक्शन)

    सिवाय (परिचालनत्रुटि, अपवाद) की_तरह ई:
        #डेटाबेस त्रुटियों और अपवादों को संभालें
        यदि कनेक्शन:
            कनेक्शन.रोलबैक()
            release_connection(कनेक्शन)
        उठाओ ई

परिभाषा मुख्य():
    प्रयत्न:
        #उदाहरण क्वेरी
        सवाल = ""चुनना * से your_table""

        #क्वेरी निष्पादित करें
        execute_query(सवाल)

        #अन्य कार्य संभालें...

    सिवाय (परिचालनत्रुटि, अपवाद) की_तरह ई:
        #त्रुटि को सुचारू रूप से लॉग करें और संभालें
        प्रिंट(""एक गलती घटित हुआ:"", स्ट्रिंग(ई))
        #यहां त्रुटि लॉगिंग और हैंडलिंग तंत्र जोड़ें

यदि __name__ == ""__main__"":
    मुख्य()"
"def celsius_to_fahrenheit(celsius):
    if celsius == 0:
        return 32

    fahrenheit = 0
    increment = 1
    if celsius < 0:
        increment = -1

    for i in range(abs(celsius)):
        fahrenheit += increment
        if fahrenheit % 5 == 0:
            increment += 1 if celsius > 0 else -1

    return fahrenheit","परिभाषा celsius_to_fahrenheit(सेल्सियस):
    यदि सेल्सियस == 0:
        वापस 32

    फ़ारेनहाइट = 0
    वेतन वृद्धि = 1
    यदि सेल्सियस < 0:
        वेतन वृद्धि = -1

    के_लिए ई में रेंज(निरपेक्ष_मान(सेल्सियस)):
        फ़ारेनहाइट += वेतन वृद्धि
        यदि फ़ारेनहाइट % 5 == 0:
            वेतन वृद्धि += 1 यदि सेल्सियस > 0 वरना -1

    वापस फ़ारेनहाइट"
"from datetime import datetime
import pytz

def get_time_difference(date1, date2):
    # Convert date strings to datetime objects
    date1 = datetime.strptime(date1, '%Y-%m-%d %H:%M:%S')
    date2 = datetime.strptime(date2, '%Y-%m-%d %H:%M:%S')

    # Get the timezone for each datetime object
    tz1 = pytz.timezone('BST')
    tz2 = pytz.timezone('PST')

    # Localize the datetime objects to their respective timezones
    date1 = tz1.localize(date1)
    date2 = tz2.localize(date2)

    # Convert both datetime objects to a common timezone (UTC in this case)
    date1 = date1.astimezone(pytz.UTC)
    date2 = date2.astimezone(pytz.UTC)

    # Calculate the time difference between the two datetime objects
    time_diff = date1 - date2

    # Extract the hours and minutes from the time difference
    hours = time_diff.seconds // 3600
    minutes = (time_diff.seconds // 60) % 60

    # Return the time difference as hours and minutes
    return f""Time difference: {hours} hours {minutes} minutes""

# Example usage
date1 = '2022-10-01 15:30:00'
date2 = '2022-09-30 23:45:00'
print(get_time_difference(date1, date2))

date1 = '2022-10-01 15:30:00'
date2 = '2022-09-30 15:45:00'
print(get_time_difference(date1, date2))","से दिनांक समय आयात दिनांक समय
आयात प्यत्ज़

परिभाषा get_time_difference(तारीख1, तारीख2):
    #दिनांक स्ट्रिंग को दिनांक-समय ऑब्जेक्ट में बदलें
    तारीख1 = दिनांक समय.स्ट्रिपटाइम(तारीख1, '%य-%एम-%डी %एच:%एम:%एस')
    तारीख2 = दिनांक समय.स्ट्रिपटाइम(तारीख2, '%य-%एम-%डी %एच:%एम:%एस')

    #प्रत्येक datetime ऑब्जेक्ट के लिए समयक्षेत्र प्राप्त करें
    टीजेड1 = प्यत्ज़.समय क्षेत्र('बीएसटी')
    टीजेड2 = प्यत्ज़.समय क्षेत्र('PST')

    #दिनांक-समय ऑब्जेक्ट को उनके संबंधित समय-क्षेत्रों में स्थानीयकृत करें
    तारीख1 = टीजेड1.स्थानीय बनाना(तारीख1)
    तारीख2 = टीजेड2.स्थानीय बनाना(तारीख2)

    #दोनों datetime ऑब्जेक्ट को एक सामान्य समयक्षेत्र में परिवर्तित करें (इस मामले में UTC)
    तारीख1 = तारीख1.एस्टीमज़ोन(प्यत्ज़.UTC)
    तारीख2 = तारीख2.एस्टीमज़ोन(प्यत्ज़.UTC)

    #दो datetime ऑब्जेक्ट्स के बीच समय अंतर की गणना करें
    time_diff = तारीख1 - तारीख2

    #समय के अंतर से घंटे और मिनट निकालें
    घंटे = time_diff.सेकंड // 3600
    मिनट = (time_diff.सेकंड // 60) % 60

    #समय का अंतर घंटों और मिनटों के रूप में लौटाएं
    वापस एफ""समय अंतर: {घंटे} घंटे {मिनट} मिनट""

#उपयोग का उदाहरण
तारीख1 = '2022-10-01 15:30:00'
तारीख2 = '2022-09-30 23:45:00'
प्रिंट(get_time_difference(तारीख1, तारीख2))

तारीख1 = '2022-10-01 15:30:00'
तारीख2 = '2022-09-30 15:45:00'
प्रिंट(get_time_difference(तारीख1, तारीख2))"
"import random
import string


def load_font_style(file_path):
    try:
        with open(file_path, 'r') as file:
            font_style = file.read()
            return font_style
    except FileNotFoundError:
        print(""Error: Font style file not found."")
        return None
    except Exception as e:
        print(f""Error: {e}"")
        return None


def generate_standard_font(word, letter_sizes):
    art = """"
    for letter in word:
        size = random.choice(letter_sizes)
        art += letter * size + ""\n""
    return art


def generate_bold_font(word, letter_sizes):
    art = """"
    for letter in word:
        size = random.choice(letter_sizes)
        art += letter.upper() * size + ""\n""
    return art


def generate_italic_font(word, letter_sizes):
    art = """"
    for letter in word:
        size = random.choice(letter_sizes)
        art += ""/"" * size + ""\n""
    return art


def generate_underline_font(word, letter_sizes):
    art = """"
    for letter in word:
        size = random.choice(letter_sizes)
        art += ""_"" * size + ""\n""
    return art


def generate_ascii_art(word, font_style, letter_sizes):
    art = """"
    for letter in word:
        if letter.isalpha():
            art += font_style(letter, letter_sizes)
        else:
            art += letter + ""\n""
    return art


def main():
    word = input(""Enter a word: "")
    font_styles = [generate_standard_font, generate_bold_font, generate_italic_font, generate_underline_font]
    font_style = random.choice(font_styles)
    letter_sizes = [1, 2, 3]
    ascii_art = generate_ascii_art(word, font_style, letter_sizes)
    print(ascii_art)


if __name__ == ""__main__"":
    main()","आयात यादृच्छिक
आयात डोरी


परिभाषा load_font_style(file_path):
    प्रयत्न:
        साथ खोल(file_path, 'आर') की_तरह फ़ाइल:
            font_style = फ़ाइल.पढ़()
            वापस font_style
    सिवाय फ़ाइलनहींमिलात्रुटि:
        प्रिंट(""गलती: फ़ॉन्ट शैली फ़ाइल ना मिला."")
        वापस कोई नहीं
    सिवाय अपवाद की_तरह ई:
        प्रिंट(एफ""गलती: {ई}"")
        वापस कोई नहीं


परिभाषा generate_standard_font(शब्द, letter_sizes):
    कला = """"
    के_लिए पत्र में शब्द:
        आकार = यादृच्छिक.पसंद(letter_sizes)
        कला += पत्र * आकार + ""\n ""
    वापस कला


परिभाषा generate_bold_font(शब्द, letter_sizes):
    कला = """"
    के_लिए पत्र में शब्द:
        आकार = यादृच्छिक.पसंद(letter_sizes)
        कला += पत्र.बड़ा() * आकार + ""\n ""
    वापस कला


परिभाषा generate_italic_font(शब्द, letter_sizes):
    कला = """"
    के_लिए पत्र में शब्द:
        आकार = यादृच्छिक.पसंद(letter_sizes)
        कला += ""/"" * आकार + ""\n ""
    वापस कला


परिभाषा generate_underline_font(शब्द, letter_sizes):
    कला = """"
    के_लिए पत्र में शब्द:
        आकार = यादृच्छिक.पसंद(letter_sizes)
        कला += ""_"" * आकार + ""\n ""
    वापस कला


परिभाषा generate_ascii_art(शब्द, font_style, letter_sizes):
    कला = """"
    के_लिए पत्र में शब्द:
        यदि पत्र.अक्षर_है():
            कला += font_style(पत्र, letter_sizes)
        वरना:
            कला += पत्र + ""\n ""
    वापस कला


परिभाषा मुख्य():
    शब्द = इनपुट(""प्रवेश करना ए शब्द: "")
    font_styles = [generate_standard_font, generate_bold_font, generate_italic_font, generate_underline_font]
    font_style = यादृच्छिक.पसंद(font_styles)
    letter_sizes = [1, 2, 3]
    ascii_art = generate_ascii_art(शब्द, font_style, letter_sizes)
    प्रिंट(ascii_art)


यदि __name__ == ""__main__"":
    मुख्य()"
"class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

def add_linked_lists(list1, list2):
    # Helper function to convert a number into a linked list
    def convert_to_linked_list(num):
        head = None
        curr = None
        while num > 0:
            digit = num % 10
            num //= 10
            new_node = Node(digit)
            if head is None:
                head = new_node
            else:
                curr.next = new_node
            curr = new_node
        return head

    # Helper function to convert a linked list into a number
    def convert_to_number(head):
        num = 0
        multiplier = 1
        while head is not None:
            num += head.data * multiplier
            multiplier *= 10
            head = head.next
        return num

    # Convert the given lists to numbers
    num1 = convert_to_number(list1)
    num2 = convert_to_number(list2)

    # Calculate the sum
    sum = num1 + num2

    # Convert the sum back to a linked list
    return convert_to_linked_list(sum)

# Create the given lists
list1 = Node(99)
list1.next = Node(99)
list1.next.next = Node(99)
list1.next.next.next = Node(99)
list1.next.next.next.next = Node(99)

list2 = Node(100)
list2.next = Node(100)
list2.next.next = Node(100)
list2.next.next.next = Node(100)
list2.next.next.next.next = Node(100)

# Add the lists and print the result
result = add_linked_lists(list1, list2)
while result is not None:
    print(result.data, end='->')
    result = result.next","वर्ग नोड:
    परिभाषा __init__(खुद, डेटा):
        खुद.डेटा = डेटा
        खुद.अगला = कोई नहीं

परिभाषा add_linked_lists(सूची1, सूची2):
    #किसी संख्या को लिंक्ड सूची में परिवर्तित करने के लिए सहायक फ़ंक्शन
    परिभाषा convert_to_linked_list(संख्या):
        सिर = कोई नहीं
        कुर = कोई नहीं
        जबतक संख्या > 0:
            अंक = संख्या % 10
            संख्या //= 10
            new_node = नोड(अंक)
            यदि सिर है कोई नहीं:
                सिर = new_node
            वरना:
                कुर.अगला = new_node
            कुर = new_node
        वापस सिर

    #लिंक्ड सूची को संख्या में परिवर्तित करने के लिए सहायक फ़ंक्शन
    परिभाषा convert_to_number(सिर):
        संख्या = 0
        गुणक = 1
        जबतक सिर है ना कोई नहीं:
            संख्या += सिर.डेटा * गुणक
            गुणक *= 10
            सिर = सिर.अगला
        वापस संख्या

    #दी गई सूचियों को संख्याओं में बदलें
    संख्या1 = convert_to_number(सूची1)
    संख्या2 = convert_to_number(सूची2)

    #योग की गणना करें
    योग = संख्या1 + संख्या2

    #योग को वापस लिंक्ड सूची में बदलें
    वापस convert_to_linked_list(योग)

#दी गई सूचियाँ बनाएँ
सूची1 = नोड(99)
सूची1.अगला = नोड(99)
सूची1.अगला.अगला = नोड(99)
सूची1.अगला.अगला.अगला = नोड(99)
सूची1.अगला.अगला.अगला.अगला = नोड(99)

सूची2 = नोड(100)
सूची2.अगला = नोड(100)
सूची2.अगला.अगला = नोड(100)
सूची2.अगला.अगला.अगला = नोड(100)
सूची2.अगला.अगला.अगला.अगला = नोड(100)

#सूचियाँ जोड़ें और परिणाम प्रिंट करें
परिणाम = add_linked_lists(सूची1, सूची2)
जबतक परिणाम है ना कोई नहीं:
    प्रिंट(परिणाम.डेटा, अंत='->')
    परिणाम = परिणाम.अगला"
"def validate_input(numbers):
    try:
        numbers = numbers.split()
        numbers = [int(number) for number in numbers]
        for number in numbers:
            if not (1 <= number <= 1000):
                raise ValueError
    except ValueError:
        print(""Invalid input! Please enter positive integers between 1 and 1000."")
        return False
    return numbers

def generate_histogram(numbers):
    histogram = {}
    for number in numbers:
        if number % 3 == 0 and number > 10:
            if number in histogram:
                histogram[number] += 1
            else:
                histogram[number] = 1
    return histogram

def display_histogram(histogram):
    sorted_histogram = sorted(histogram.items(), key=lambda x: x[1], reverse=True)
    print(""Histogram:"")
    for number, frequency in sorted_histogram:
        print(f""{number}: {'*' * frequency}"")

numbers_input = input(""Enter the numbers (separated by spaces): "")
numbers = validate_input(numbers_input)
if numbers:
    histogram = generate_histogram(numbers)
    display_histogram(histogram)","परिभाषा validate_input(नंबर):
    प्रयत्न:
        नंबर = नंबर.बाँट()
        नंबर = [अंक(संख्या) के_लिए संख्या में नंबर]
        के_लिए संख्या में नंबर:
            यदि ना (1 <= संख्या <= 1000):
                उठाओ मान_त्रुटि
    सिवाय मान_त्रुटि:
        प्रिंट(""अमान्य इनपुट! कृपया प्रवेश करना सकारात्मक पूर्णांकों बीच में 1 और 1000."")
        वापस असत्य
    वापस नंबर

परिभाषा generate_histogram(नंबर):
    हिस्टोग्राम = {}
    के_लिए संख्या में नंबर:
        यदि संख्या % 3 == 0 और संख्या > 10:
            यदि संख्या में हिस्टोग्राम:
                हिस्टोग्राम[संख्या] += 1
            वरना:
                हिस्टोग्राम[संख्या] = 1
    वापस हिस्टोग्राम

परिभाषा display_histogram(हिस्टोग्राम):
    sorted_histogram = क्रमबद्ध(हिस्टोग्राम.सामान(), चाबी=लैम्ब्डा एक्स: एक्स[1], उलट=सत्य)
    प्रिंट(""हिस्टोग्राम:"")
    के_लिए संख्या, आवृत्ति में sorted_histogram:
        प्रिंट(एफ""{संख्या}: {'*' * आवृत्ति}"")

numbers_input = इनपुट(""प्रवेश करना  नंबर (अलग द्वारा खाली स्थान): "")
नंबर = validate_input(numbers_input)
यदि नंबर:
    हिस्टोग्राम = generate_histogram(नंबर)
    display_histogram(हिस्टोग्राम)"
"def sieve_of_eratosthenes(n):
    primes = [True] * (n + 1)
    primes[0] = primes[1] = False

    p = 2
    while p * p <= n:
        if primes[p]:
            for i in range(p * p, n + 1, p):
                primes[i] = False
        p += 1

    return primes

def get_primes(numbers):
    max_num = max(numbers)
    sieve = sieve_of_eratosthenes(max_num)
    
    primes = []
    for num in numbers:
        if sieve[num]:
            primes.append(num)
    
    return primes

numbers = [1, 2, 3, 4, 5, 6]
primes = get_primes(numbers)
print(primes)","परिभाषा sieve_of_eratosthenes(एन):
    अभाज्य = [सत्य] * (एन + 1)
    अभाज्य[0] = अभाज्य[1] = असत्य

    पी = 2
    जबतक पी * पी <= एन:
        यदि अभाज्य[पी]:
            के_लिए ई में रेंज(पी * पी, एन + 1, पी):
                अभाज्य[ई] = असत्य
        पी += 1

    वापस अभाज्य

परिभाषा get_primes(नंबर):
    max_num = अधिकतम(नंबर)
    चलनी = sieve_of_eratosthenes(max_num)

    अभाज्य = []
    के_लिए संख्या में नंबर:
        यदि चलनी[संख्या]:
            अभाज्य.संलग्न(संख्या)

    वापस अभाज्य

नंबर = [1, 2, 3, 4, 5, 6]
अभाज्य = get_primes(नंबर)
प्रिंट(अभाज्य)"
"list_of_numbers = [10, 7, 5, 12, 4]

sorted_list = sorted(list_of_numbers, reverse=True)

# Finding the difference between the largest and smallest prime numbers
def find_prime_difference(numbers):
    primes = []
    for num in numbers:
        if num > 1:
            is_prime = True
            for i in range(2, int(num**0.5) + 1):
                if (num % i) == 0:
                    is_prime = False
                    break
            if is_prime:
                primes.append(num)

    if len(primes) > 1:
        return max(primes) - min(primes)
    else:
        return None

prime_difference = find_prime_difference(sorted_list)

if prime_difference is not None:
    print(""Difference between the largest and smallest prime numbers:"", prime_difference)
else:
    print(""No prime numbers found."")","list_of_numbers = [10, 7, 5, 12, 4]

sorted_list = क्रमबद्ध(list_of_numbers, उलट=सत्य)

#सबसे बड़ी और सबसे छोटी अभाज्य संख्याओं के बीच अंतर ज्ञात करना
परिभाषा find_prime_difference(नंबर):
    अभाज्य = []
    के_लिए संख्या में नंबर:
        यदि संख्या > 1:
            is_prime = सत्य
            के_लिए ई में रेंज(2, अंक(संख्या**0.5) + 1):
                यदि (संख्या % ई) == 0:
                    is_prime = असत्य
                    तोड़
            यदि is_prime:
                अभाज्य.संलग्न(संख्या)

    यदि लंबाई(अभाज्य) > 1:
        वापस अधिकतम(अभाज्य) - न्यूनतम(अभाज्य)
    वरना:
        वापस कोई नहीं

prime_difference = find_prime_difference(sorted_list)

यदि prime_difference है ना कोई नहीं:
    प्रिंट(""अंतर बीच में  सबसे बड़ा और सबसे छोटा मुख्य नंबर:"", prime_difference)
वरना:
    प्रिंट(""नहीं मुख्य नंबर मिला."")"
"def remove_value(data, value):
    if isinstance(data, list):
        result = []
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result.append(remove_value(item, value))
            elif isinstance(item, dict):
                result.append(remove_value(list(item.values()), value))
            elif item != value:
                result.append(item)
        return result
    elif isinstance(data, dict):
        result = {}
        for key, item in data.items():
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result[key] = remove_value(item, value)
            elif isinstance(item, dict):
                result[key] = remove_value(list(item.values()), value)
            elif item != value:
                result[key] = item
        return result
    elif isinstance(data, tuple):
        result = ()
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result += (remove_value(item, value),)
            elif isinstance(item, dict):
                result += (remove_value(list(item.values()), value),)
            elif item != value:
                result += (item,)
        return result
    elif isinstance(data, set):
        result = set()
        for item in data:
            if isinstance(item, list) or isinstance(item, tuple) or isinstance(item, set):
                result.add(remove_value(item, value))
            elif isinstance(item, dict):
                result.add(remove_value(list(item.values()), value))
            elif item != value:
                result.add(item)
        return result
    else:
        return data

# Example usage
data = [1, 2, 3, [4, 5, [6, 7]], {'a': [1, 2, 3]}, (1, 2, 3), {1, 2, 3}]
value = 3

result = remove_value(data, value)
print(result)","परिभाषा remove_value(डेटा, कीमत):
    यदि उदाहरण_है(डेटा, सूची):
        परिणाम = []
        के_लिए वस्तु में डेटा:
            यदि उदाहरण_है(वस्तु, सूची) या उदाहरण_है(वस्तु, ट्यूपल) या उदाहरण_है(वस्तु, सेट):
                परिणाम.संलग्न(remove_value(वस्तु, कीमत))
            वरना_यदि उदाहरण_है(वस्तु, कोश):
                परिणाम.संलग्न(remove_value(सूची(वस्तु.मान()), कीमत))
            वरना_यदि वस्तु != कीमत:
                परिणाम.संलग्न(वस्तु)
        वापस परिणाम
    वरना_यदि उदाहरण_है(डेटा, कोश):
        परिणाम = {}
        के_लिए चाबी, वस्तु में डेटा.सामान():
            यदि उदाहरण_है(वस्तु, सूची) या उदाहरण_है(वस्तु, ट्यूपल) या उदाहरण_है(वस्तु, सेट):
                परिणाम[चाबी] = remove_value(वस्तु, कीमत)
            वरना_यदि उदाहरण_है(वस्तु, कोश):
                परिणाम[चाबी] = remove_value(सूची(वस्तु.मान()), कीमत)
            वरना_यदि वस्तु != कीमत:
                परिणाम[चाबी] = वस्तु
        वापस परिणाम
    वरना_यदि उदाहरण_है(डेटा, ट्यूपल):
        परिणाम = ()
        के_लिए वस्तु में डेटा:
            यदि उदाहरण_है(वस्तु, सूची) या उदाहरण_है(वस्तु, ट्यूपल) या उदाहरण_है(वस्तु, सेट):
                परिणाम += (remove_value(वस्तु, कीमत),)
            वरना_यदि उदाहरण_है(वस्तु, कोश):
                परिणाम += (remove_value(सूची(वस्तु.मान()), कीमत),)
            वरना_यदि वस्तु != कीमत:
                परिणाम += (वस्तु,)
        वापस परिणाम
    वरना_यदि उदाहरण_है(डेटा, सेट):
        परिणाम = सेट()
        के_लिए वस्तु में डेटा:
            यदि उदाहरण_है(वस्तु, सूची) या उदाहरण_है(वस्तु, ट्यूपल) या उदाहरण_है(वस्तु, सेट):
                परिणाम.योग(remove_value(वस्तु, कीमत))
            वरना_यदि उदाहरण_है(वस्तु, कोश):
                परिणाम.योग(remove_value(सूची(वस्तु.मान()), कीमत))
            वरना_यदि वस्तु != कीमत:
                परिणाम.योग(वस्तु)
        वापस परिणाम
    वरना:
        वापस डेटा

#उपयोग का उदाहरण
डेटा = [1, 2, 3, [4, 5, [6, 7]], {'ए': [1, 2, 3]}, (1, 2, 3), {1, 2, 3}]
कीमत = 3

परिणाम = remove_value(डेटा, कीमत)
प्रिंट(परिणाम)"
"def average_temperature(temperatures):
    if len(temperatures) == 0:
        raise ValueError(""No temperatures provided."")
    
    total = sum(temperatures)
    average = total / len(temperatures)
    
    return round(average)","परिभाषा average_temperature(तापमान):
    यदि लंबाई(तापमान) == 0:
        उठाओ मान_त्रुटि(""नहीं तापमान प्रदान किया."")

    कुल = योग(तापमान)
    औसत = कुल / लंबाई(तापमान)

    वापस गोल(औसत)"
"list_of_temperatures = [20, 24, -5, -10, 26, 18]
print(average_temperature(list_of_temperatures))","list_of_temperatures = [20, 24, -5, -10, 26, 18]
प्रिंट(average_temperature(list_of_temperatures))"
"def elementwise_product(vector1, vector2):
    n = len(vector1)
    result = []
    for i in range(n):
        result.append(vector1[i] * vector2[i])
    return result","परिभाषा elementwise_product(वेक्टर1, वेक्टर2):
    एन = लंबाई(वेक्टर1)
    परिणाम = []
    के_लिए ई में रेंज(एन):
        परिणाम.संलग्न(वेक्टर1[ई] * वेक्टर2[ई])
    वापस परिणाम"
"import math

def calculate_modulo(x, y):
    """"""
    This function takes two positive integers, x and y, as input and calculates the modulo of x divided by y.
    The function returns the result of the modulo calculation.
    """"""

    if not isinstance(x, int) or not isinstance(y, int) or x < 0 or y < 0:
        raise ValueError(""The input arguments must be positive integers."")

    if y == 0:
        raise ZeroDivisionError(""Cannot divide by zero."")

    while x >= y:
        x -= y

    return x

x = 5
y = 2

try:
    x_mod_y = calculate_modulo(x, y)
    print(""The modulo of {} divided by {} is: {}"".format(x, y, x_mod_y))

    if x_mod_y < 2:
        print(""The modulo result is not a prime number."")
    else:
        is_prime = True
        for i in range(2, int(math.sqrt(x_mod_y)) + 1):
            if x_mod_y % i == 0:
                is_prime = False
                break
        
        if is_prime:
            print(""The modulo result is a prime number."")
        else:
            print(""The modulo result is not a prime number."")
except ValueError as e:
    print(""Error:"", e)
except ZeroDivisionError as e:
    print(""Error:"", e)","आयात गणित

परिभाषा calculate_modulo(एक्स, य):
    """"""
    यह समारोह लेता है दो सकारात्मक पूर्णांकों, एक्स और य, की_तरह इनपुट और की गणना करता है  सापेक्ष का एक्स विभाजित द्वारा य.
     समारोह रिटर्न  परिणाम का  सापेक्ष गणना.
    """"""

    यदि ना उदाहरण_है(एक्स, अंक) या ना उदाहरण_है(य, अंक) या एक्स < 0 या य < 0:
        उठाओ मान_त्रुटि("" इनपुट बहस अवश्य होना सकारात्मक पूर्णांकों."")

    यदि य == 0:
        उठाओ शून्य_भाग_त्रुटि(""नही सकता विभाजित करना द्वारा शून्य."")

    जबतक एक्स >= य:
        एक्स -= य

    वापस एक्स

एक्स = 5
य = 2

प्रयत्न:
    x_mod_y = calculate_modulo(एक्स, य)
    प्रिंट("" सापेक्ष का {} विभाजित द्वारा {} है: {}"".प्रारूप(एक्स, य, x_mod_y))

    यदि x_mod_y < 2:
        प्रिंट("" सापेक्ष परिणाम है ना ए मुख्य संख्या."")
    वरना:
        is_prime = सत्य
        के_लिए ई में रेंज(2, अंक(गणित.एसक्यूआरटी(x_mod_y)) + 1):
            यदि x_mod_y % ई == 0:
                is_prime = असत्य
                तोड़

        यदि is_prime:
            प्रिंट("" सापेक्ष परिणाम है ए मुख्य संख्या."")
        वरना:
            प्रिंट("" सापेक्ष परिणाम है ना ए मुख्य संख्या."")
सिवाय मान_त्रुटि की_तरह ई:
    प्रिंट(""गलती:"", ई)
सिवाय शून्य_भाग_त्रुटि की_तरह ई:
    प्रिंट(""गलती:"", ई)"
"def remove_duplicates(numbers):
    sorted_numbers = sorted(numbers)
    result = []
    for number in sorted_numbers:
        if number not in result:
            result.append(number)
    
    return sorted(result, key=lambda x: (abs(x), -x))","परिभाषा remove_duplicates(नंबर):
    sorted_numbers = क्रमबद्ध(नंबर)
    परिणाम = []
    के_लिए संख्या में sorted_numbers:
        यदि संख्या ना में परिणाम:
            परिणाम.संलग्न(संख्या)

    वापस क्रमबद्ध(परिणाम, चाबी=लैम्ब्डा एक्स: (निरपेक्ष_मान(एक्स), -एक्स))"
"print(remove_duplicates([1, 2, 3, 3, 2, 1, -1, -2, -3, -3, -2, -1]))
# Output: [-1, 1, -2, 2, -3, 3]

print(remove_duplicates([4, -4, 2, 1, 3, -3, -2, -1]))
# Output: [-1, 1, -2, 2, -3, 3, 4]

print(remove_duplicates([]))
# Output: []

print(remove_duplicates([5]))
# Output: [5]","प्रिंट(remove_duplicates([1, 2, 3, 3, 2, 1, -1, -2, -3, -3, -2, -1]))
#आउटपुट: [-1, 1, -2, 2, -3, 3]

प्रिंट(remove_duplicates([4, -4, 2, 1, 3, -3, -2, -1]))
#आउटपुट: [-1, 1, -2, 2, -3, 3, 4]

प्रिंट(remove_duplicates([]))
#आउटपुट: []

प्रिंट(remove_duplicates([5]))
#आउटपुट: [5]"
"def longest_consecutive_uppercase(string):
    max_len = 0
    curr_len = 0
    max_start = 0
    curr_start = 0
    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}
    
    for i in range(len(string)):
        if string[i].isupper() and string[i] not in vowels:
            curr_len += 1
            if curr_len == 1:
                curr_start = i
            if curr_len > max_len:
                max_len = curr_len
                max_start = curr_start
        else:
            curr_len = 0
    
    return string[max_start: max_start + max_len]","परिभाषा longest_consecutive_uppercase(डोरी):
    max_len = 0
    curr_len = 0
    max_start = 0
    curr_start = 0
    स्वर = {'ए', 'ई', 'ई', 'हे', 'यू', 'ए', 'इ', 'मैं', 'हे', 'यू'}

    के_लिए ई में रेंज(लंबाई(डोरी)):
        यदि डोरी[ई].बड़ा_है() और डोरी[ई] ना में स्वर:
            curr_len += 1
            यदि curr_len == 1:
                curr_start = ई
            यदि curr_len > max_len:
                max_len = curr_len
                max_start = curr_start
        वरना:
            curr_len = 0

    वापस डोरी[max_start: max_start + max_len]"
"def calculate_transpose(matrix):
    # Get the number of rows and columns
    m = len(matrix)
    n = len(matrix[0])
    
    # Create a new matrix with n rows and m columns
    transpose = [[0 for _ in range(m)] for _ in range(n)]
    
    # Calculate the transpose by swapping rows with columns
    for i in range(m):
        for j in range(n):
            transpose[j][i] = matrix[i][j]
    
    return transpose","परिभाषा calculate_transpose(मैट्रिक्स):
    #पंक्तियों और स्तंभों की संख्या प्राप्त करें
    एम = लंबाई(मैट्रिक्स)
    एन = लंबाई(मैट्रिक्स[0])

    #n पंक्तियों और m स्तंभों वाला एक नया मैट्रिक्स बनाएँ
    खिसकाना = [[0 के_लिए _ में रेंज(एम)] के_लिए _ में रेंज(एन)]

    #पंक्तियों को स्तंभों से बदलकर ट्रांसपोज़ की गणना करें
    के_लिए ई में रेंज(एम):
        के_लिए जे में रेंज(एन):
            खिसकाना[जे][ई] = मैट्रिक्स[ई][जे]

    वापस खिसकाना"
"def calculate_transpose(matrix):
    # Get the number of rows and columns
    m = len(matrix)
    n = len(matrix[0])
    
    # Create a new matrix with n rows and m columns
    transpose = [[0 for _ in range(m)] for _ in range(n)]
    
    # Calculate the transpose by swapping rows with columns
    for i in range(m):
        for j in range(n):
            transpose[j][i] = matrix[i][j]
    
    # Check if the matrix is symmetric
    symmetric = True
    for i in range(m):
        for j in range(n):
            if matrix[i][j] != transpose[i][j]:
                symmetric = False
                break
    
    return symmetric, transpose","परिभाषा calculate_transpose(मैट्रिक्स):
    #पंक्तियों और स्तंभों की संख्या प्राप्त करें
    एम = लंबाई(मैट्रिक्स)
    एन = लंबाई(मैट्रिक्स[0])

    #n पंक्तियों और m स्तंभों वाला एक नया मैट्रिक्स बनाएँ
    खिसकाना = [[0 के_लिए _ में रेंज(एम)] के_लिए _ में रेंज(एन)]

    #पंक्तियों को स्तंभों से बदलकर ट्रांसपोज़ की गणना करें
    के_लिए ई में रेंज(एम):
        के_लिए जे में रेंज(एन):
            खिसकाना[जे][ई] = मैट्रिक्स[ई][जे]

    #जाँच करें कि मैट्रिक्स सममित है या नहीं
    सममित = सत्य
    के_लिए ई में रेंज(एम):
        के_लिए जे में रेंज(एन):
            यदि मैट्रिक्स[ई][जे] != खिसकाना[ई][जे]:
                सममित = असत्य
                तोड़

    वापस सममित, खिसकाना"
"def count_vowels(string):
    vowels = {'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}
    vowel_positions = {}

    for i, char in enumerate(string):
        if char.isalpha():
            char_lower = char.lower()
            if char_lower in vowels:
                vowels[char_lower] += 1
                if char_lower not in vowel_positions:
                    vowel_positions[char_lower] = []
                vowel_positions[char_lower].append(i)

    return vowel_positions if vowel_positions else {}

# Example usage:
print(count_vowels(""Hello, World!""))  # Output: {'e': [1], 'o': [4], 'o': [7]}
print(count_vowels(""This is a test""))  # Output: {'i': [2], 'i': [5], 'a': [8]}
print(count_vowels(""No vowels here""))  # Output: {}
print(count_vowels(""""))  # Output: {}","परिभाषा count_vowels(डोरी):
    स्वर = {'ए': 0, 'ई': 0, 'ई': 0, 'हे': 0, 'यू': 0}
    vowel_positions = {}

    के_लिए ई, चार में गणना(डोरी):
        यदि चार.अक्षर_है():
            char_lower = चार.छोटा()
            यदि char_lower में स्वर:
                स्वर[char_lower] += 1
                यदि char_lower ना में vowel_positions:
                    vowel_positions[char_lower] = []
                vowel_positions[char_lower].संलग्न(ई)

    वापस vowel_positions यदि vowel_positions वरना {}

#उदाहरण उपयोग:
प्रिंट(count_vowels(""नमस्ते, दुनिया!"")) #आउटपुट: {'e': [1], 'o': [4], 'o': [7]}
प्रिंट(count_vowels(""यह है ए परीक्षा"")) #आउटपुट: {'i': [2], 'i': [5], 'a': [8]}
प्रिंट(count_vowels(""नहीं स्वर यहाँ"")) #आउटपुट: {}
प्रिंट(count_vowels("""")) #आउटपुट: {}"
"def roman_numerals(string):
    # dictionary to map decimal numbers to Roman numerals
    roman_dict = {
        1: 'I',
        4: 'IV',
        5: 'V',
        9: 'IX',
        10: 'X',
        40: 'XL',
        50: 'L',
        90: 'XC',
        100: 'C',
        400: 'CD',
        500: 'D',
        900: 'CM',
        1000: 'M'
    }

    result = ''
    i = 0
    while i < len(string):
        if string[i].isdigit():
            # find the maximum decimal number that is less than or equal to the current number
            num = ''
            while i < len(string) and string[i].isdigit():
                num += string[i]
                i += 1
            num = int(num)

            # convert the decimal number to Roman numeral
            for decimal, roman in sorted(roman_dict.items(), reverse=True):
                if num >= decimal:
                    result += roman
                    num -= decimal

            # skip consecutive Roman numerals
            while i < len(string) and string[i].isalpha() and string[i].upper() in roman_dict.values():
                i += 1
        else:
            result += string[i]
            i += 1

    return result","परिभाषा roman_numerals(डोरी):
    #दशमलव संख्याओं को रोमन अंकों में मैप करने के लिए शब्दकोश
    roman_dict = {
        1: 'मैं',
        4: 'चतुर्थ',
        5: 'वी',
        9: 'नौवीं',
        10: 'एक्स',
        40: 'एक्स्ट्रा लार्ज',
        50: 'एल',
        90: 'एक्ससी',
        100: 'सी',
        400: 'सीडी',
        500: 'डी',
        900: 'सेमी',
        1000: 'एम'
    }

    परिणाम = ''
    ई = 0
    जबतक ई < लंबाई(डोरी):
        यदि डोरी[ई].अंक_है():
            #वह अधिकतम दशमलव संख्या ज्ञात करें जो वर्तमान संख्या से कम या उसके बराबर हो
            संख्या = ''
            जबतक ई < लंबाई(डोरी) और डोरी[ई].अंक_है():
                संख्या += डोरी[ई]
                ई += 1
            संख्या = अंक(संख्या)

            #दशमलव संख्या को रोमन अंक में बदलें
            के_लिए दशमलव, रोमन में क्रमबद्ध(roman_dict.सामान(), उलट=सत्य):
                यदि संख्या >= दशमलव:
                    परिणाम += रोमन
                    संख्या -= दशमलव

            #लगातार रोमन अंक छोड़ें
            जबतक ई < लंबाई(डोरी) और डोरी[ई].अक्षर_है() और डोरी[ई].बड़ा() में roman_dict.मान():
                ई += 1
        वरना:
            परिणाम += डोरी[ई]
            ई += 1

    वापस परिणाम"
"print(roman_numerals('abc 123 def'))  # Output: abc CXXIII def
print(roman_numerals('I love 2 code in Python'))  # Output: I love II code in Python
print(roman_numerals('Roman numerals: 1, 2, 3, 4, 5'))  # Output: Roman numerals: I, II, III, IV, V
print(roman_numerals('Testing 1234567890'))  # Output: Testing MCCCLXIX","प्रिंट(roman_numerals('एबीसी 123 परिभाषा')) #आउटपुट: abc CXXIII def
प्रिंट(roman_numerals('मैं प्यार 2 कोड में पायथन')) #आउटपुट: मुझे पायथन में II कोड पसंद है
प्रिंट(roman_numerals('रोमन अंकों: 1, 2, 3, 4, 5')) #आउटपुट: रोमन अंक: I, II, III, IV, V
प्रिंट(roman_numerals('परीक्षण 1234567890')) #आउटपुट: MCCCLXIX का परीक्षण"
"def get_long_words(string):
    # Remove leading and trailing spaces
    string = string.strip()
    
    # Convert the string to lowercase
    string = string.lower()
    
    # Split the string into words
    words = string.split()
    
    # Initialize a set to store words with duplicate characters
    duplicates = set()
    
    # Initialize a list to store valid words
    result = []
    
    # Iterate through each word
    for word in words:
        # Check if the word has more than 7 characters
        if len(word) > 7:
            # Check if the word contains duplicate characters
            if len(set(word)) == len(word):
                # Add the word to the result list
                result.append(word)
            else:
                # Add the word to the duplicates set
                duplicates.add(word)
    
    return result","परिभाषा get_long_words(डोरी):
    #आरंभिक और अंतिम रिक्त स्थान हटाएं
    डोरी = डोरी.उघाड़()

    #स्ट्रिंग को लोअरकेस में बदलें
    डोरी = डोरी.छोटा()

    #स्ट्रिंग को शब्दों में विभाजित करें
    शब्द = डोरी.बाँट()

    #डुप्लिकेट वर्णों वाले शब्दों को संग्रहीत करने के लिए एक सेट आरंभ करें
    डुप्लिकेट = सेट()

    #मान्य शब्दों को संग्रहीत करने के लिए सूची आरंभ करें
    परिणाम = []

    #प्रत्येक शब्द को दोहराएँ
    के_लिए शब्द में शब्द:
        #जाँचें कि शब्द में 7 से अधिक अक्षर हैं या नहीं
        यदि लंबाई(शब्द) > 7:
            #जाँचें कि क्या शब्द में डुप्लिकेट अक्षर हैं
            यदि लंबाई(सेट(शब्द)) == लंबाई(शब्द):
                #शब्द को परिणाम सूची में जोड़ें
                परिणाम.संलग्न(शब्द)
            वरना:
                #शब्द को डुप्लिकेट सेट में जोड़ें
                डुप्लिकेट.योग(शब्द)

    वापस परिणाम"
"print(get_long_words(""Hello, world!""))
# Output: ['world']

print(get_long_words(""   Hello   ""))
# Output: ['hello']

print(get_long_words(""This is a test sentence with words that have more than 7 characters.""))
# Output: ['sentence', 'characters']","प्रिंट(get_long_words(""नमस्ते, दुनिया!""))
#आउटपुट: ['world']

प्रिंट(get_long_words(""   नमस्ते   ""))
#आउटपुट: ['हैलो']

प्रिंट(get_long_words(""यह है ए परीक्षा वाक्य साथ शब्द वह पास होना अधिक बजाय 7 वर्ण.""))
#आउटपुट: ['वाक्य', 'अक्षर']"
"def is_prime(num):
    if num <= 1:
        return False
    for i in range(2, int(num**0.5) + 1):
        if num % i == 0:
            return False
    return True

def sum_of_unique_primes(arr):
    prime_sum = 0
    primes_seen = set()

    for num in arr:
        if num in primes_seen:
            continue

        if is_prime(num):
            prime_sum += num
            primes_seen.add(num)

    return prime_sum

arr = [3, 5, 8, 10, 4, 13, 17, 8, 10, 13, 4]
print(sum_of_unique_primes(arr))","परिभाषा is_prime(संख्या):
    यदि संख्या <= 1:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(संख्या**0.5) + 1):
        यदि संख्या % ई == 0:
            वापस असत्य
    वापस सत्य

परिभाषा sum_of_unique_primes(आगमन):
    prime_sum = 0
    primes_seen = सेट()

    के_लिए संख्या में आगमन:
        यदि संख्या में primes_seen:
            जारी

        यदि is_prime(संख्या):
            prime_sum += संख्या
            primes_seen.योग(संख्या)

    वापस prime_sum

आगमन = [3, 5, 8, 10, 4, 13, 17, 8, 10, 13, 4]
प्रिंट(sum_of_unique_primes(आगमन))"
"def sum_even_numbers_iterative(lst):
    total = 0
    stack = [lst]

    while stack:
        current = stack.pop()
        if isinstance(current, list):
            stack.extend(current)
        elif isinstance(current, int) and current % 2 == 0:
            total += current

    return total


def sum_even_numbers_recursive(lst):
    total = 0

    for item in lst:
        if isinstance(item, list):
            total += sum_even_numbers_recursive(item)
        elif isinstance(item, int) and item % 2 == 0:
            total += item

    return total


# Example usage
lst = [1, 2, 3, 4, [5, 6, [7, 8], 9], 10]
print(sum_even_numbers_iterative(lst))  # Output: 30
print(sum_even_numbers_recursive(lst))  # Output: 30","परिभाषा sum_even_numbers_iterative(प्रथम):
    कुल = 0
    ढेर = [प्रथम]

    जबतक ढेर:
        मौजूदा = ढेर.पॉप()
        यदि उदाहरण_है(मौजूदा, सूची):
            ढेर.बढ़ा(मौजूदा)
        वरना_यदि उदाहरण_है(मौजूदा, अंक) और मौजूदा % 2 == 0:
            कुल += मौजूदा

    वापस कुल


परिभाषा sum_even_numbers_recursive(प्रथम):
    कुल = 0

    के_लिए वस्तु में प्रथम:
        यदि उदाहरण_है(वस्तु, सूची):
            कुल += sum_even_numbers_recursive(वस्तु)
        वरना_यदि उदाहरण_है(वस्तु, अंक) और वस्तु % 2 == 0:
            कुल += वस्तु

    वापस कुल


#उपयोग का उदाहरण
प्रथम = [1, 2, 3, 4, [5, 6, [7, 8], 9], 10]
प्रिंट(sum_even_numbers_iterative(प्रथम)) #आउटपुट: 30
प्रिंट(sum_even_numbers_recursive(प्रथम)) #आउटपुट: 30"
"def count_duplicates(lst):
    # Create an empty dictionary to store the count of each element
    count_dict = {}
    # Create an empty list to store the unique elements with their counts
    unique_list = []

    # Iterate through the input list
    for num in lst:
        # Check if the element is already in the dictionary
        if num in count_dict:
            # If it is, increment its count by 1
            count_dict[num] += 1
        else:
            # If it is not, add it to the dictionary with a count of 1
            count_dict[num] = 1

    # Iterate through the input list again
    for num in lst:
        # Check if the count of the element is greater than 0
        if count_dict[num] > 0:
            # If it is, add the element and its count as a tuple to the unique list
            unique_list.append((num, count_dict[num]))
            # Set the count of the element to 0 to mark it as visited
            count_dict[num] = 0

    # Return the unique list
    return unique_list","परिभाषा count_duplicates(प्रथम):
    #प्रत्येक तत्व की गिनती संग्रहीत करने के लिए एक खाली शब्दकोश बनाएं
    count_dict = {}
    #अद्वितीय तत्वों को उनकी संख्या के साथ संग्रहीत करने के लिए एक खाली सूची बनाएं
    unique_list = []

    #इनपुट सूची के माध्यम से पुनरावृति करें
    के_लिए संख्या में प्रथम:
        #जाँचें कि तत्व पहले से ही शब्दकोश में है या नहीं
        यदि संख्या में count_dict:
            #यदि ऐसा है, तो इसकी गिनती 1 से बढ़ाएँ
            count_dict[संख्या] += 1
        वरना:
            #यदि ऐसा नहीं है, तो इसे 1 की गिनती के साथ शब्दकोश में जोड़ें
            count_dict[संख्या] = 1

    #इनपुट सूची को फिर से दोहराएँ
    के_लिए संख्या में प्रथम:
        #जाँचें कि क्या तत्व की संख्या 0 से अधिक है
        यदि count_dict[संख्या] > 0:
            #यदि ऐसा है, तो तत्व और उसकी गिनती को टपल के रूप में अद्वितीय सूची में जोड़ें
            unique_list.संलग्न((संख्या, count_dict[संख्या]))
            #तत्व को विज़िट किया गया के रूप में चिह्नित करने के लिए उसकी गिनती 0 पर सेट करें
            count_dict[संख्या] = 0

    #अद्वितीय सूची लौटाएँ
    वापस unique_list"
"lst = [2, 3, 2, 4, 5, 5, 6]
result = count_duplicates(lst)
print(result)","प्रथम = [2, 3, 2, 4, 5, 5, 6]
परिणाम = count_duplicates(प्रथम)
प्रिंट(परिणाम)"
"import math

def largest_prime_factor(n):
    # Divide by 2 until it is no longer divisible
    while n % 2 == 0:
        n //= 2

    # Check odd numbers up to sqrt(n)
    for i in range(3, int(math.sqrt(n)) + 1, 2):
        while n % i == 0:
            n //= i

    # If n is still greater than 2, it is a prime factor
    if n > 2:
        return n
    else:
        return None","आयात गणित

परिभाषा largest_prime_factor(एन):
    #2 से तब तक विभाजित करें जब तक कि यह विभाज्य न रह जाए
    जबतक एन % 2 == 0:
        एन //= 2

    #sqrt(n) तक विषम संख्याओं की जाँच करें
    के_लिए ई में रेंज(3, अंक(गणित.एसक्यूआरटी(एन)) + 1, 2):
        जबतक एन % ई == 0:
            एन //= ई

    #यदि n अभी भी 2 से अधिक है, तो यह एक अभाज्य गुणनखंड है
    यदि एन > 2:
        वापस एन
    वरना:
        वापस कोई नहीं"
"n = 1001
while True:
    result = largest_prime_factor(n)
    if result is not None and result > 1000:
        break
    n += 1

print(result)","एन = 1001
जबतक सत्य:
    परिणाम = largest_prime_factor(एन)
    यदि परिणाम है ना कोई नहीं और परिणाम > 1000:
        तोड़
    एन += 1

प्रिंट(परिणाम)"
"class NotPrimeError(Exception):
    pass

def check_product(a, b):
    # Check if a and b are positive integers
    if not isinstance(a, int) or not isinstance(b, int) or a <= 0 or b <= 0:
        raise ValueError(""Both parameters must be positive integers"")
    
    # Check if a and b are within the specified range
    if a < 1 or a > 1000 or b < 1 or b > 1000:
        raise ValueError(""Both parameters must be within the range of 1 to 1000 (inclusive)"")
    
    # Calculate the product
    product = a * b
    
    # Check if the product is a prime number
    if not is_prime(product):
        raise NotPrimeError(""The product is not a prime number"")
    
    return product

def is_prime(n):
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False
    i = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return False
        i += 6
    return True","वर्ग नॉटप्राइमएरर(अपवाद):
    जाने_दो

परिभाषा check_product(ए, बी):
    #जाँच करें कि क्या a और b धनात्मक पूर्णांक हैं
    यदि ना उदाहरण_है(ए, अंक) या ना उदाहरण_है(बी, अंक) या ए <= 0 या बी <= 0:
        उठाओ मान_त्रुटि(""दोनों पैरामीटर अवश्य होना सकारात्मक पूर्णांकों"")

    #जाँचें कि क्या a और b निर्दिष्ट सीमा के भीतर हैं
    यदि ए < 1 या ए > 1000 या बी < 1 या बी > 1000:
        उठाओ मान_त्रुटि(""दोनों पैरामीटर अवश्य होना अंदर  रेंज का 1 को 1000 (सहित)"")

    #गुणनफल की गणना करें
    उत्पाद = ए * बी

    #जाँचें कि गुणनफल अभाज्य संख्या है या नहीं
    यदि ना is_prime(उत्पाद):
        उठाओ नॉटप्राइमएरर("" उत्पाद है ना ए मुख्य संख्या"")

    वापस उत्पाद

परिभाषा is_prime(एन):
    यदि एन <= 1:
        वापस असत्य
    यदि एन <= 3:
        वापस सत्य
    यदि एन % 2 == 0 या एन % 3 == 0:
        वापस असत्य
    ई = 5
    जबतक ई * ई <= एन:
        यदि एन % ई == 0 या एन % (ई + 2) == 0:
            वापस असत्य
        ई += 6
    वापस सत्य"
"def remove_vowels(string):
    vowels = ['a', 'e', 'i', 'o', 'u']
    for vowel in vowels:
        string = string.replace(vowel, """")
    
    words = string.split()
    new_string = """"
    for word in words:
        if word[0].lower() not in vowels:  # case-insensitive check
            new_string += word + "" ""
    
    sorted_words = sorted(new_string.split(), key=lambda x: (-len(x), x.lower()))
    return "" "".join(sorted_words)

string = ""hello world, how are you?""
result = remove_vowels(string)
print(result)","परिभाषा remove_vowels(डोरी):
    स्वर = ['ए', 'ई', 'ई', 'हे', 'यू']
    के_लिए स्वर में स्वर:
        डोरी = डोरी.बदल(स्वर, """")

    शब्द = डोरी.बाँट()
    new_string = """"
    के_लिए शब्द में शब्द:
        यदि शब्द[0].छोटा() ना में स्वर: #केस-असंवेदनशील जाँच
            new_string += शब्द + "" ""

    sorted_words = क्रमबद्ध(new_string.बाँट(), चाबी=लैम्ब्डा एक्स: (-लंबाई(एक्स), एक्स.छोटा()))
    वापस "" "".जोड़(sorted_words)

डोरी = ""नमस्ते दुनिया, कैसे हैं आप?""
परिणाम = remove_vowels(डोरी)
प्रिंट(परिणाम)"
"def find_max(lst):
    # Base case: if the list has only one element, return it as the maximum
    if len(lst) == 1:
        return lst[0]
    
    # Recursive case: divide the list into two halves and recursively find the maximum in each half
    mid = len(lst) // 2
    max_left = find_max(lst[:mid])
    max_right = find_max(lst[mid:])
    
    # Return the maximum of the two halves
    return max(max_left, max_right)","परिभाषा find_max(प्रथम):
    #आधार स्थिति: यदि सूची में केवल एक तत्व है, तो उसे अधिकतम के रूप में लौटाएं
    यदि लंबाई(प्रथम) == 1:
        वापस प्रथम[0]

    #पुनरावर्ती मामला: सूची को दो हिस्सों में विभाजित करें और प्रत्येक आधे में अधिकतम संख्या पुनरावर्ती रूप से ज्ञात करें
    मध्य = लंबाई(प्रथम) // 2
    max_left = find_max(प्रथम[:मध्य])
    max_right = find_max(प्रथम[मध्य:])

    #दोनों हिस्सों में से अधिकतम लौटाएँ
    वापस अधिकतम(max_left, max_right)"
"def harmonic_mean(numbers):
    if len(numbers) < 3:
        return ""Input list should have at least 3 numbers.""

    for num in numbers:
        if num < 0:
            return ""Input list contains negative numbers.""

    if len(set(numbers)) != len(numbers):
        return ""Input list contains duplicate numbers.""

    try:
        harmonic_mean = len(numbers) / sum([1/num for num in numbers])
    except ZeroDivisionError:
        return ""Input list contains zeros. Division by zero is not allowed.""

    return harmonic_mean","परिभाषा harmonic_mean(नंबर):
    यदि लंबाई(नंबर) < 3:
        वापस ""इनपुट सूची चाहिए पास होना पर कम से कम 3 नंबर.""

    के_लिए संख्या में नंबर:
        यदि संख्या < 0:
            वापस ""इनपुट सूची रोकना नकारात्मक नंबर.""

    यदि लंबाई(सेट(नंबर)) != लंबाई(नंबर):
        वापस ""इनपुट सूची रोकना डुप्लिकेट नंबर.""

    प्रयत्न:
        harmonic_mean = लंबाई(नंबर) / योग([1/संख्या के_लिए संख्या में नंबर])
    सिवाय शून्य_भाग_त्रुटि:
        वापस ""इनपुट सूची रोकना शून्य. विभाजन द्वारा शून्य है ना अनुमत.""

    वापस harmonic_mean"
"def harmonic_mean_error(numbers):
    if len(numbers) < 3:
        return ""Input list should have at least 3 numbers.""

    for num in numbers:
        if num < 0:
            return ""Input list contains negative numbers.""

    if len(set(numbers)) != len(numbers):
        return ""Input list contains duplicate numbers.""

    try:
        harmonic_mean_error = len(numbers) / sum(numbers)
    except ZeroDivisionError:
        return ""Input list contains zeros. Division by zero is not allowed.""

    return harmonic_mean_error","परिभाषा harmonic_mean_error(नंबर):
    यदि लंबाई(नंबर) < 3:
        वापस ""इनपुट सूची चाहिए पास होना पर कम से कम 3 नंबर.""

    के_लिए संख्या में नंबर:
        यदि संख्या < 0:
            वापस ""इनपुट सूची रोकना नकारात्मक नंबर.""

    यदि लंबाई(सेट(नंबर)) != लंबाई(नंबर):
        वापस ""इनपुट सूची रोकना डुप्लिकेट नंबर.""

    प्रयत्न:
        harmonic_mean_error = लंबाई(नंबर) / योग(नंबर)
    सिवाय शून्य_भाग_त्रुटि:
        वापस ""इनपुट सूची रोकना शून्य. विभाजन द्वारा शून्य है ना अनुमत.""

    वापस harmonic_mean_error"
"import random

def initialize_matrix(matrix, row, col):
    if row >= len(matrix) or col >= len(matrix[0]):
        return
    
    matrix[row][col] = random.randint(0, 1)
    
    if col + 1 < len(matrix[0]):
        initialize_matrix(matrix, row, col + 1)
    else:
        initialize_matrix(matrix, row + 1, 0)","आयात यादृच्छिक

परिभाषा initialize_matrix(मैट्रिक्स, पंक्ति, कर्नल):
    यदि पंक्ति >= लंबाई(मैट्रिक्स) या कर्नल >= लंबाई(मैट्रिक्स[0]):
        वापस

    मैट्रिक्स[पंक्ति][कर्नल] = यादृच्छिक.रैंडिंट(0, 1)

    यदि कर्नल + 1 < लंबाई(मैट्रिक्स[0]):
        initialize_matrix(मैट्रिक्स, पंक्ति, कर्नल + 1)
    वरना:
        initialize_matrix(मैट्रिक्स, पंक्ति + 1, 0)"
"def is_anagram(str1, str2):
    # Trim whitespace and convert to lowercase
    str1 = str1.strip().lower()
    str2 = str2.strip().lower()

    # Check if strings are empty or have length less than 2
    if len(str1) < 2 or len(str2) < 2:
        return False

    # Create frequency dictionaries for characters in both strings
    freq1 = {}
    freq2 = {}

    for char in str1:
        freq1[char] = freq1.get(char, 0) + 1

    for char in str2:
        freq2[char] = freq2.get(char, 0) + 1

    # Compare the frequency dictionaries
    return freq1 == freq2


# Example usage
string1 = ""Listen""
string2 = ""Silent""

if is_anagram(string1, string2):
    print(f""{string1} and {string2} are anagrams."")
else:
    print(f""{string1} and {string2} are not anagrams."")","परिभाषा is_anagram(स्ट्रिंग1, स्ट्रिंग2):
    #रिक्त स्थान को काटें और लोअरकेस में बदलें
    स्ट्रिंग1 = स्ट्रिंग1.उघाड़().छोटा()
    स्ट्रिंग2 = स्ट्रिंग2.उघाड़().छोटा()

    #जाँचें कि क्या स्ट्रिंग्स रिक्त हैं या उनकी लंबाई 2 से कम है
    यदि लंबाई(स्ट्रिंग1) < 2 या लंबाई(स्ट्रिंग2) < 2:
        वापस असत्य

    #दोनों स्ट्रिंग्स में वर्णों के लिए आवृत्ति शब्दकोश बनाएँ
    फ्रीक1 = {}
    फ्रीक2 = {}

    के_लिए चार में स्ट्रिंग1:
        फ्रीक1[चार] = फ्रीक1.पाना(चार, 0) + 1

    के_लिए चार में स्ट्रिंग2:
        फ्रीक2[चार] = फ्रीक2.पाना(चार, 0) + 1

    #आवृत्ति शब्दकोशों की तुलना करें
    वापस फ्रीक1 == फ्रीक2


#उपयोग का उदाहरण
डोरी1 = ""सुनना""
डोरी2 = ""चुपचाप""

यदि is_anagram(डोरी1, डोरी2):
    प्रिंट(एफ""{डोरी1} और {डोरी2} हैं अनाग्रामज़."")
वरना:
    प्रिंट(एफ""{डोरी1} और {डोरी2} हैं ना अनाग्रामज़."")"
"def find_prime_factors(num):
    factors = []
    divisor = 2
    while divisor <= num:
        if num % divisor == 0:
            factors.append(divisor)
            num = num / divisor
        else:
            divisor += 1
    return factors

def main():
    num = int(input(""Enter a number: ""))
    prime_factors = find_prime_factors(num)
    if prime_factors:
        print(""Prime factors:"", prime_factors)
    else:
        print(""Number is prime"")

if __name__ == '__main__':
    main()","परिभाषा find_prime_factors(संख्या):
    कारकों = []
    विभाजक = 2
    जबतक विभाजक <= संख्या:
        यदि संख्या % विभाजक == 0:
            कारकों.संलग्न(विभाजक)
            संख्या = संख्या / विभाजक
        वरना:
            विभाजक += 1
    वापस कारकों

परिभाषा मुख्य():
    संख्या = अंक(इनपुट(""प्रवेश करना ए संख्या: ""))
    prime_factors = find_prime_factors(संख्या)
    यदि prime_factors:
        प्रिंट(""मुख्य कारकों:"", prime_factors)
    वरना:
        प्रिंट(""संख्या है मुख्य"")

यदि __name__ == '__main__':
    मुख्य()"
"def is_prime(n):
    if n <= 1:
        return False
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

prime_numbers = []
for num in range(1, 10001):
    if is_prime(num):
        prime_numbers.append(num)

prime_sum = sum(prime_numbers)
prime_average = prime_sum / len(prime_numbers)
prime_count = len(prime_numbers)

print(""Prime Numbers:"", prime_numbers)
print(""Sum of Prime Numbers:"", prime_sum)
print(""Average of Prime Numbers:"", prime_average)
print(""Number of Prime Numbers Found:"", prime_count)","परिभाषा is_prime(एन):
    यदि एन <= 1:
        वापस असत्य
    के_लिए ई में रेंज(2, अंक(एन ** 0.5) + 1):
        यदि एन % ई == 0:
            वापस असत्य
    वापस सत्य

prime_numbers = []
के_लिए संख्या में रेंज(1, 10001):
    यदि is_prime(संख्या):
        prime_numbers.संलग्न(संख्या)

prime_sum = योग(prime_numbers)
prime_average = prime_sum / लंबाई(prime_numbers)
prime_count = लंबाई(prime_numbers)

प्रिंट(""मुख्य नंबर:"", prime_numbers)
प्रिंट(""जोड़ का मुख्य नंबर:"", prime_sum)
प्रिंट(""औसत का मुख्य नंबर:"", prime_average)
प्रिंट(""संख्या का मुख्य नंबर मिला:"", prime_count)"
"def sort_list(lst):
    # Sort numbers in descending order
    for i in range(len(lst) - 1):
        for j in range(len(lst) - i - 1):
            if isinstance(lst[j], (int, float)) and isinstance(lst[j + 1], (int, float)):
                if lst[j] < lst[j + 1]:
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
    
    # Sort strings in alphabetical order
    for i in range(len(lst) - 1):
        for j in range(len(lst) - i - 1):
            if isinstance(lst[j], str) and isinstance(lst[j + 1], str):
                if lst[j] > lst[j + 1]:
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
    
    # Sort nested lists based on the sum of their elements
    for i in range(len(lst) - 1):
        for j in range(len(lst) - i - 1):
            if isinstance(lst[j], list) and isinstance(lst[j + 1], list):
                if sum(lst[j]) < sum(lst[j + 1]):
                    lst[j], lst[j + 1] = lst[j + 1], lst[j]
    
    return lst","परिभाषा sort_list(प्रथम):
    #संख्याओं को अवरोही क्रम में छाँटें
    के_लिए ई में रेंज(लंबाई(प्रथम) - 1):
        के_लिए जे में रेंज(लंबाई(प्रथम) - ई - 1):
            यदि उदाहरण_है(प्रथम[जे], (अंक, दश)) और उदाहरण_है(प्रथम[जे + 1], (अंक, दश)):
                यदि प्रथम[जे] < प्रथम[जे + 1]:
                    प्रथम[जे], प्रथम[जे + 1] = प्रथम[जे + 1], प्रथम[जे]

    #स्ट्रिंग्स को वर्णानुक्रम में क्रमबद्ध करें
    के_लिए ई में रेंज(लंबाई(प्रथम) - 1):
        के_लिए जे में रेंज(लंबाई(प्रथम) - ई - 1):
            यदि उदाहरण_है(प्रथम[जे], स्ट्रिंग) और उदाहरण_है(प्रथम[जे + 1], स्ट्रिंग):
                यदि प्रथम[जे] > प्रथम[जे + 1]:
                    प्रथम[जे], प्रथम[जे + 1] = प्रथम[जे + 1], प्रथम[जे]

    #नेस्टेड सूचियों को उनके तत्वों के योग के आधार पर क्रमबद्ध करें
    के_लिए ई में रेंज(लंबाई(प्रथम) - 1):
        के_लिए जे में रेंज(लंबाई(प्रथम) - ई - 1):
            यदि उदाहरण_है(प्रथम[जे], सूची) और उदाहरण_है(प्रथम[जे + 1], सूची):
                यदि योग(प्रथम[जे]) < योग(प्रथम[जे + 1]):
                    प्रथम[जे], प्रथम[जे + 1] = प्रथम[जे + 1], प्रथम[जे]

    वापस प्रथम"
"print(sort_list([5, 2, 3, 4, 1, 5]))  # [5, 5, 4, 3, 2, 1]
print(sort_list([""apple"", ""banana"", ""carrot""]))  # [""apple"", ""banana"", ""carrot""]
print(sort_list([10, ""apple"", 5, ""banana"", 3, [1, 2], [3, 4]]))  # [10, 5, 3, [3, 4], [1, 2], ""apple"", ""banana""]
print(sort_list([[3, 4], [1, 2], [5, 6], [1, 2, 3], [1, 2, 4], [1, 2, 3, 4]]))  # [[1, 2, 3, 4], [1, 2, 3], [5, 6], [1, 2, 4], [1, 2], [3, 4]]","प्रिंट(sort_list([5, 2, 3, 4, 1, 5])) #[5, 5, 4, 3, 2, 1]
प्रिंट(sort_list([""सेब"", ""केला"", ""गाजर""])) #[""सेब"", ""केला"", ""गाजर""]
प्रिंट(sort_list([10, ""सेब"", 5, ""केला"", 3, [1, 2], [3, 4]])) #[10, 5, 3, [3, 4], [1, 2], ""सेब"", ""केला""]
प्रिंट(sort_list([[3, 4], [1, 2], [5, 6], [1, 2, 3], [1, 2, 4], [1, 2, 3, 4]])) #[[1, 2, 3, 4], [1, 2, 3], [5, 6], [1, 2, 4], [1, 2], [3, 4]]"
"import re

def unique_words(string):
    # Remove punctuation marks and special characters
    string = re.sub(r'[^\w\s]', '', string)
    
    # Split the string into a list of words
    words = string.split()
    
    # Create a set to store unique words
    unique_words_set = set()
    
    # Create a list to store unique words in order
    unique_words_list = []
    
    # Iterate through the words in the list
    for word in words:
        # Check if the word is already in the set
        if word not in unique_words_set:
            # If not, add it to the set and list
            unique_words_set.add(word)
            unique_words_list.append(word)
    
    return unique_words_list","आयात दोबारा

परिभाषा unique_words(डोरी):
    #विराम चिह्न और विशेष वर्ण हटाएं
    डोरी = दोबारा.उप(आर'[^\व\एस]', '', डोरी)

    #स्ट्रिंग को शब्दों की सूची में विभाजित करें
    शब्द = डोरी.बाँट()

    #अद्वितीय शब्दों को संग्रहीत करने के लिए एक सेट बनाएँ
    unique_words_set = सेट()

    #अद्वितीय शब्दों को क्रम में संग्रहीत करने के लिए एक सूची बनाएं
    unique_words_list = []

    #सूची में दिए गए शब्दों को दोहराएँ
    के_लिए शब्द में शब्द:
        #जाँचें कि क्या शब्द पहले से सेट में है
        यदि शब्द ना में unique_words_set:
            #यदि नहीं, तो इसे सेट और सूची में जोड़ें
            unique_words_set.योग(शब्द)
            unique_words_list.संलग्न(शब्द)

    वापस unique_words_list"
"string = ""Hello world hello again""
result = unique_words(string)
print(result)  # Output: ['Hello', 'world', 'hello', 'again']","डोरी = ""नमस्ते दुनिया नमस्ते दोबारा""
परिणाम = unique_words(डोरी)
प्रिंट(परिणाम) #आउटपुट: ['हैलो', 'वर्ल्ड', 'हैलो', 'फिर से']"
